{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RaBe cridlib for Python Generate RaBe CRIDs based on several data sources: Songticker for current CRID archiv.rabe.ch for past CRIDs LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe) Installation poetry add rabe-cridlib # or on old setup style projects pip -m install rabe-cridlib Usage >>> import cridlib >>> >>> # parse an existing crid >>> crid = cridlib . parse ( \"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\" ) >>> print ( f \"version: { crid . version } , show: { crid . show } , start: { crid . start } \" ) version : v1 , show : klangbecken , start : 1993 - 03 - 01 13 : 12 : 00 >>> # get crid for current show >>> crid = cridlib . get () >>> print ( f \"version: { crid . version } , show: { crid . show } \" ) # doctest:+ELLIPSIS version : v1 , show : ... Development # setup a dev env python -mvenv env . env/bin/activate # install a modern poetry version python -mpip install poetry> = 1 .2.0 # install deps and dev version poetry install # make changes, run tests pytest Release Management The CI/CD setup uses semantic commit messages following the conventional commits standard . There is a GitHub Action semantic-release.yaml in radiorabe/actions that uses go-semantic-commit to create new releases. The commit message should be structured as follows: <type>[optional scope]: <description> [optional body] [optional footer(s)] The commit contains the following structural elements, to communicate intent to the consumers of your library: fix: a commit of the type fix patches gets released with a PATCH version bump feat: a commit of the type feat gets released as a MINOR version bump BREAKING CHANGE: a commit that has a footer BREAKING CHANGE: gets released as a MAJOR version bump types other than fix: and feat: are allowed and don't trigger a release If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR. Once a commit has landed on the main branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi. License This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License. Copyright Copyright (c) 2022 Radio Bern RaBe","title":"Information"},{"location":"#rabe-cridlib-for-python","text":"Generate RaBe CRIDs based on several data sources: Songticker for current CRID archiv.rabe.ch for past CRIDs LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe)","title":"RaBe cridlib for Python"},{"location":"#installation","text":"poetry add rabe-cridlib # or on old setup style projects pip -m install rabe-cridlib","title":"Installation"},{"location":"#usage","text":">>> import cridlib >>> >>> # parse an existing crid >>> crid = cridlib . parse ( \"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\" ) >>> print ( f \"version: { crid . version } , show: { crid . show } , start: { crid . start } \" ) version : v1 , show : klangbecken , start : 1993 - 03 - 01 13 : 12 : 00 >>> # get crid for current show >>> crid = cridlib . get () >>> print ( f \"version: { crid . version } , show: { crid . show } \" ) # doctest:+ELLIPSIS version : v1 , show : ...","title":"Usage"},{"location":"#development","text":"# setup a dev env python -mvenv env . env/bin/activate # install a modern poetry version python -mpip install poetry> = 1 .2.0 # install deps and dev version poetry install # make changes, run tests pytest","title":"Development"},{"location":"#release-management","text":"The CI/CD setup uses semantic commit messages following the conventional commits standard . There is a GitHub Action semantic-release.yaml in radiorabe/actions that uses go-semantic-commit to create new releases. The commit message should be structured as follows: <type>[optional scope]: <description> [optional body] [optional footer(s)] The commit contains the following structural elements, to communicate intent to the consumers of your library: fix: a commit of the type fix patches gets released with a PATCH version bump feat: a commit of the type feat gets released as a MINOR version bump BREAKING CHANGE: a commit that has a footer BREAKING CHANGE: gets released as a MAJOR version bump types other than fix: and feat: are allowed and don't trigger a release If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR. Once a commit has landed on the main branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi.","title":"Release Management"},{"location":"#license","text":"This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.","title":"License"},{"location":"#copyright","text":"Copyright (c) 2022 Radio Bern RaBe","title":"Copyright"},{"location":"reference/SUMMARY/","text":"cridlib get lib parse strategy future now past","title":"SUMMARY"},{"location":"reference/cridlib/","text":"Generate RaBe Content Reference Idenitifier Spcification (CRID) Identifiers. get(timestamp=None, fragment='') Get a RaBe CRID. If you need to get the CRID for a specific point in RaBe time using a human-readable timezone: >>> from datetime import datetime >>> from pytz import timezone >>> crid = get ( datetime ( 2020 , 3 , 1 , 00 , 00 , tzinfo = timezone ( 'Europe/Zurich' ))) >>> print ( f \"version: { crid . version } , start: { crid . start } \" ) version : v1 , start : ... parse(value) Get CRID dataclass from CRID.","title":"cridlib"},{"location":"reference/cridlib/#cridlib--gettimestampnone-fragment","text":"Get a RaBe CRID. If you need to get the CRID for a specific point in RaBe time using a human-readable timezone: >>> from datetime import datetime >>> from pytz import timezone >>> crid = get ( datetime ( 2020 , 3 , 1 , 00 , 00 , tzinfo = timezone ( 'Europe/Zurich' ))) >>> print ( f \"version: { crid . version } , start: { crid . start } \" ) version : v1 , start : ...","title":"\u0002wzxhzdk:2\u0003"},{"location":"reference/cridlib/#cridlib--parsevalue","text":"Get CRID dataclass from CRID.","title":"\u0002wzxhzdk:3\u0003"},{"location":"reference/cridlib/get/","text":"Main \"get\" interface for RaBe CRID's. get ( timestamp = None , fragment = '' ) Get a RaBe CRID. If you need to get the CRID for a specific point in RaBe time using a human-readable timezone: >>> from datetime import datetime >>> from pytz import timezone >>> crid = get ( datetime ( 2020 , 3 , 1 , 00 , 00 , tzinfo = timezone ( 'Europe/Zurich' ))) >>> print ( f \"version: { crid . version } , start: { crid . start } \" ) version : v1 , start : ... Source code in cridlib/get.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get ( timestamp = None , fragment = \"\" ) -> CRID : \"\"\"Get a RaBe CRID. If you need to get the CRID for a specific point in RaBe time using a human-readable timezone: ```python >>> from datetime import datetime >>> from pytz import timezone >>> crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich'))) >>> print(f\"version: {crid.version}, start: {crid.start}\") version: v1, start: ... ``` \"\"\" _now = datetime . now ( timezone . utc ) _ts = timestamp or _now _show = \"\" if _ts == _now : _show = now . get_show () elif _ts < _now : _show = past . get_show ( past = _ts ) elif _ts > _now : # pragma: no cover _show = future . get_show ( future = _ts ) if _show : _show = canonicalize_show ( _show ) _tscode = f \"t=clock= { _ts . strftime ( '%Y%m %d T%H%M%S. %f ' )[: - 4 ] } Z\" _fragment = f \" { _tscode }{ '&' + fragment if fragment else '' } \" return CRID ( f \"crid://rabe.ch/v1 { '/' + _show if _show else '' } # { _fragment } \" )","title":"get"},{"location":"reference/cridlib/get/#cridlib.get.get","text":"Get a RaBe CRID. If you need to get the CRID for a specific point in RaBe time using a human-readable timezone: >>> from datetime import datetime >>> from pytz import timezone >>> crid = get ( datetime ( 2020 , 3 , 1 , 00 , 00 , tzinfo = timezone ( 'Europe/Zurich' ))) >>> print ( f \"version: { crid . version } , start: { crid . start } \" ) version : v1 , start : ... Source code in cridlib/get.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def get ( timestamp = None , fragment = \"\" ) -> CRID : \"\"\"Get a RaBe CRID. If you need to get the CRID for a specific point in RaBe time using a human-readable timezone: ```python >>> from datetime import datetime >>> from pytz import timezone >>> crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich'))) >>> print(f\"version: {crid.version}, start: {crid.start}\") version: v1, start: ... ``` \"\"\" _now = datetime . now ( timezone . utc ) _ts = timestamp or _now _show = \"\" if _ts == _now : _show = now . get_show () elif _ts < _now : _show = past . get_show ( past = _ts ) elif _ts > _now : # pragma: no cover _show = future . get_show ( future = _ts ) if _show : _show = canonicalize_show ( _show ) _tscode = f \"t=clock= { _ts . strftime ( '%Y%m %d T%H%M%S. %f ' )[: - 4 ] } Z\" _fragment = f \" { _tscode }{ '&' + fragment if fragment else '' } \" return CRID ( f \"crid://rabe.ch/v1 { '/' + _show if _show else '' } # { _fragment } \" )","title":"get()"},{"location":"reference/cridlib/lib/","text":"Low-level cridlib implemenetation bits. CRID Represent CRIDs using uri. Source code in cridlib/lib.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class CRID : \"\"\"Represent CRIDs using uri.\"\"\" def __init__ ( self , _uri = None ) -> None : self . _show : Optional [ str ] = None self . _start : Optional [ datetime ] = None self . _uri = urisplit ( _uri ) if self . scheme != \"crid\" : raise CRIDSchemeMismatchError ( self . scheme , _uri ) if self . authority != \"rabe.ch\" : raise CRIDSchemeAuthorityMismatchError ( self . authority , _uri ) # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path if self . path . parent . stem != \"v1\" and self . path . stem != \"v1\" : raise CRIDUnsupportedVersionError ( self . path , _uri ) self . _version = self . path . parent . stem or self . path . stem # only store show if we have one if self . path . stem != \"v1\" : self . _show = self . path . relative_to ( self . path . parent ) . stem # fragments are optional, but if provided we want them to contain t=code if self . fragment : try : self . _start = datetime . strptime ( parse_qs ( parse_qs ( self . fragment )[ \"t\" ][ 0 ])[ \"clock\" ][ 0 ], \"%Y%m %d T%H%M%S. %f Z\" , ) except KeyError as ex : raise CRIDMissingMediaFragmentError ( self . fragment , _uri ) from ex except ValueError as ex : # pragma: no cover raise CRIDMalformedMediaFragmentError ( self . fragment , _uri ) from ex def __str__ ( self ) -> str : return uricompose ( * self . _uri ) def __repr__ ( self ) -> str : \"\"\"Pretty print CRID. ```python >>> CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\") <class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'> ``` \"\"\" _fqcn = f \" { self . __class__ . __module__ } . { self . __class__ . __qualname__ } \" return f \"<class ' { _fqcn } ' for ' { str ( self ) } '>\" @property def scheme ( self ) -> str : \"\"\"Get RaBe CRID scheme.\"\"\" return self . _uri . scheme @property def authority ( self ) -> str : \"\"\"Get RaBe CRID authority.\"\"\" return self . _uri . authority @property def path ( self ) -> CRIDPath : \"\"\"Get RaBe CRID path.\"\"\" return CRIDPath ( self . _uri . path ) @property def fragment ( self ) -> str : \"\"\"Get RaBe CRID fragment.\"\"\" return self . _uri . fragment @property def version ( self ) -> str : \"\"\"Get RaBe CRID version.\"\"\" return self . _version @property def show ( self ) -> Optional [ str ]: \"\"\"Get RaBe CRID show.\"\"\" return self . _show @property def start ( self ) -> Optional [ datetime ]: \"\"\"Get RaBe CRID start time.\"\"\" return self . _start authority : str property Get RaBe CRID authority. fragment : str property Get RaBe CRID fragment. path : CRIDPath property Get RaBe CRID path. scheme : str property Get RaBe CRID scheme. show : Optional [ str ] property Get RaBe CRID show. start : Optional [ datetime ] property Get RaBe CRID start time. version : str property Get RaBe CRID version. __repr__ () Pretty print CRID. >>> CRID ( \"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\" ) < class ' cridlib . lib . CRID ' for ' crid : // rabe . ch / v1 / test #t=clock=19930301T131200.00Z'> Source code in cridlib/lib.py 78 79 80 81 82 83 84 85 86 87 88 89 def __repr__ ( self ) -> str : \"\"\"Pretty print CRID. ```python >>> CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\") <class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'> ``` \"\"\" _fqcn = f \" { self . __class__ . __module__ } . { self . __class__ . __qualname__ } \" return f \"<class ' { _fqcn } ' for ' { str ( self ) } '>\" CRIDError Bases: Exception Represent all cridlib errors. Source code in cridlib/lib.py 17 18 class CRIDError ( Exception ): \"\"\"Represent all cridlib errors.\"\"\" CRIDMalformedMediaFragmentError Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 37 38 class CRIDMalformedMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\" CRIDMissingMediaFragmentError Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 33 34 class CRIDMissingMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\" CRIDSchemeAuthorityMismatchError Bases: CRIDError Hostname part of URI does not match 'rabe.ch'. Source code in cridlib/lib.py 25 26 class CRIDSchemeAuthorityMismatchError ( CRIDError ): \"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\" CRIDSchemeMismatchError Bases: CRIDError Scheme in URI does not match 'crid'. Source code in cridlib/lib.py 21 22 class CRIDSchemeMismatchError ( CRIDError ): \"\"\"Scheme in URI does not match 'crid'.\"\"\" CRIDUnsupportedVersionError Bases: CRIDError Unsupported version in path of URI. Source code in cridlib/lib.py 29 30 class CRIDUnsupportedVersionError ( CRIDError ): \"\"\"Unsupported version in path of URI.\"\"\" canonicalize_show ( show ) Get the slug for a show using python-slugify. Source code in cridlib/lib.py 12 13 14 def canonicalize_show ( show : str ): \"\"\"Get the slug for a show using python-slugify.\"\"\" return slugify ( show )","title":"lib"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID","text":"Represent CRIDs using uri. Source code in cridlib/lib.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class CRID : \"\"\"Represent CRIDs using uri.\"\"\" def __init__ ( self , _uri = None ) -> None : self . _show : Optional [ str ] = None self . _start : Optional [ datetime ] = None self . _uri = urisplit ( _uri ) if self . scheme != \"crid\" : raise CRIDSchemeMismatchError ( self . scheme , _uri ) if self . authority != \"rabe.ch\" : raise CRIDSchemeAuthorityMismatchError ( self . authority , _uri ) # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path if self . path . parent . stem != \"v1\" and self . path . stem != \"v1\" : raise CRIDUnsupportedVersionError ( self . path , _uri ) self . _version = self . path . parent . stem or self . path . stem # only store show if we have one if self . path . stem != \"v1\" : self . _show = self . path . relative_to ( self . path . parent ) . stem # fragments are optional, but if provided we want them to contain t=code if self . fragment : try : self . _start = datetime . strptime ( parse_qs ( parse_qs ( self . fragment )[ \"t\" ][ 0 ])[ \"clock\" ][ 0 ], \"%Y%m %d T%H%M%S. %f Z\" , ) except KeyError as ex : raise CRIDMissingMediaFragmentError ( self . fragment , _uri ) from ex except ValueError as ex : # pragma: no cover raise CRIDMalformedMediaFragmentError ( self . fragment , _uri ) from ex def __str__ ( self ) -> str : return uricompose ( * self . _uri ) def __repr__ ( self ) -> str : \"\"\"Pretty print CRID. ```python >>> CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\") <class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'> ``` \"\"\" _fqcn = f \" { self . __class__ . __module__ } . { self . __class__ . __qualname__ } \" return f \"<class ' { _fqcn } ' for ' { str ( self ) } '>\" @property def scheme ( self ) -> str : \"\"\"Get RaBe CRID scheme.\"\"\" return self . _uri . scheme @property def authority ( self ) -> str : \"\"\"Get RaBe CRID authority.\"\"\" return self . _uri . authority @property def path ( self ) -> CRIDPath : \"\"\"Get RaBe CRID path.\"\"\" return CRIDPath ( self . _uri . path ) @property def fragment ( self ) -> str : \"\"\"Get RaBe CRID fragment.\"\"\" return self . _uri . fragment @property def version ( self ) -> str : \"\"\"Get RaBe CRID version.\"\"\" return self . _version @property def show ( self ) -> Optional [ str ]: \"\"\"Get RaBe CRID show.\"\"\" return self . _show @property def start ( self ) -> Optional [ datetime ]: \"\"\"Get RaBe CRID start time.\"\"\" return self . _start","title":"CRID"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority","text":"Get RaBe CRID authority.","title":"authority"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment","text":"Get RaBe CRID fragment.","title":"fragment"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path","text":"Get RaBe CRID path.","title":"path"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme","text":"Get RaBe CRID scheme.","title":"scheme"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show","text":"Get RaBe CRID show.","title":"show"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start","text":"Get RaBe CRID start time.","title":"start"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version","text":"Get RaBe CRID version.","title":"version"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__repr__","text":"Pretty print CRID. >>> CRID ( \"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\" ) < class ' cridlib . lib . CRID ' for ' crid : // rabe . ch / v1 / test #t=clock=19930301T131200.00Z'> Source code in cridlib/lib.py 78 79 80 81 82 83 84 85 86 87 88 89 def __repr__ ( self ) -> str : \"\"\"Pretty print CRID. ```python >>> CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\") <class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'> ``` \"\"\" _fqcn = f \" { self . __class__ . __module__ } . { self . __class__ . __qualname__ } \" return f \"<class ' { _fqcn } ' for ' { str ( self ) } '>\"","title":"__repr__()"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDError","text":"Bases: Exception Represent all cridlib errors. Source code in cridlib/lib.py 17 18 class CRIDError ( Exception ): \"\"\"Represent all cridlib errors.\"\"\"","title":"CRIDError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMalformedMediaFragmentError","text":"Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 37 38 class CRIDMalformedMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\"","title":"CRIDMalformedMediaFragmentError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMissingMediaFragmentError","text":"Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 33 34 class CRIDMissingMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\"","title":"CRIDMissingMediaFragmentError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeAuthorityMismatchError","text":"Bases: CRIDError Hostname part of URI does not match 'rabe.ch'. Source code in cridlib/lib.py 25 26 class CRIDSchemeAuthorityMismatchError ( CRIDError ): \"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\"","title":"CRIDSchemeAuthorityMismatchError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeMismatchError","text":"Bases: CRIDError Scheme in URI does not match 'crid'. Source code in cridlib/lib.py 21 22 class CRIDSchemeMismatchError ( CRIDError ): \"\"\"Scheme in URI does not match 'crid'.\"\"\"","title":"CRIDSchemeMismatchError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDUnsupportedVersionError","text":"Bases: CRIDError Unsupported version in path of URI. Source code in cridlib/lib.py 29 30 class CRIDUnsupportedVersionError ( CRIDError ): \"\"\"Unsupported version in path of URI.\"\"\"","title":"CRIDUnsupportedVersionError"},{"location":"reference/cridlib/lib/#cridlib.lib.canonicalize_show","text":"Get the slug for a show using python-slugify. Source code in cridlib/lib.py 12 13 14 def canonicalize_show ( show : str ): \"\"\"Get the slug for a show using python-slugify.\"\"\" return slugify ( show )","title":"canonicalize_show()"},{"location":"reference/cridlib/parse/","text":"Parse RaBe CRID's. parse ( value ) Get CRID dataclass from CRID. Source code in cridlib/parse.py 6 7 8 def parse ( value : str ) -> CRID : \"\"\"Get CRID dataclass from CRID.\"\"\" return CRID ( value )","title":"parse"},{"location":"reference/cridlib/parse/#cridlib.parse.parse","text":"Get CRID dataclass from CRID. Source code in cridlib/parse.py 6 7 8 def parse ( value : str ) -> CRID : \"\"\"Get CRID dataclass from CRID.\"\"\" return CRID ( value )","title":"parse()"},{"location":"reference/cridlib/strategy/","text":"","title":"strategy"},{"location":"reference/cridlib/strategy/future/","text":"The future strategy implements getting data from LibreTime. get_show ( future ) Return the slug for a show from LibreTime if it is in the next 7 days. Source code in cridlib/strategy/future.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_show ( future : datetime ) -> str : # pragma: no cover \"\"\"Return the slug for a show from LibreTime if it is in the next 7 days.\"\"\" _resp = requests . get ( __LIBRETIME_INFOV2_URL , params = { \"days\" : 7 , \"shows\" : 7000 , }, timeout = 10 , ) _json = _resp . json () _tz = _json . get ( \"station\" ) . get ( \"timezone\" ) _next = _json . get ( \"shows\" ) . get ( \"next\" ) for _show in _next : _start = datetime . fromisoformat ( _show . get ( \"starts\" )) . replace ( tzinfo = timezone . utc ) _end = datetime . fromisoformat ( _show . get ( \"ends\" )) . replace ( tzinfo = timezone . utc ) if _start <= future <= _end : _path = PurePath ( urisplit ( _show . get ( \"url\" )) . path ) return _path . stem return \"\"","title":"future"},{"location":"reference/cridlib/strategy/future/#cridlib.strategy.future.get_show","text":"Return the slug for a show from LibreTime if it is in the next 7 days. Source code in cridlib/strategy/future.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def get_show ( future : datetime ) -> str : # pragma: no cover \"\"\"Return the slug for a show from LibreTime if it is in the next 7 days.\"\"\" _resp = requests . get ( __LIBRETIME_INFOV2_URL , params = { \"days\" : 7 , \"shows\" : 7000 , }, timeout = 10 , ) _json = _resp . json () _tz = _json . get ( \"station\" ) . get ( \"timezone\" ) _next = _json . get ( \"shows\" ) . get ( \"next\" ) for _show in _next : _start = datetime . fromisoformat ( _show . get ( \"starts\" )) . replace ( tzinfo = timezone . utc ) _end = datetime . fromisoformat ( _show . get ( \"ends\" )) . replace ( tzinfo = timezone . utc ) if _start <= future <= _end : _path = PurePath ( urisplit ( _show . get ( \"url\" )) . path ) return _path . stem return \"\"","title":"get_show()"},{"location":"reference/cridlib/strategy/now/","text":"The now strategy implements getting data from Songticker. get_show () Return the currently running shows slug from nowplaying. Source code in cridlib/strategy/now.py 12 13 14 15 16 17 18 def get_show () -> str : \"\"\"Return the currently running shows slug from nowplaying.\"\"\" _resp = requests . get ( __SONGTICKER_URL , timeout = 10 ) _tree = ET . fromstring ( _resp . text ) _path = PurePath ( urisplit ( _tree [ 3 ][ 1 ] . text ) . path ) return _path . stem","title":"now"},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show","text":"Return the currently running shows slug from nowplaying. Source code in cridlib/strategy/now.py 12 13 14 15 16 17 18 def get_show () -> str : \"\"\"Return the currently running shows slug from nowplaying.\"\"\" _resp = requests . get ( __SONGTICKER_URL , timeout = 10 ) _tree = ET . fromstring ( _resp . text ) _path = PurePath ( urisplit ( _tree [ 3 ][ 1 ] . text ) . path ) return _path . stem","title":"get_show()"},{"location":"reference/cridlib/strategy/past/","text":"The past strategy implements getting data from archiv.rabe.ch. get_show ( past ) Return the a show slug from a past show. Source code in cridlib/strategy/past.py 10 11 12 13 14 15 16 17 18 19 def get_show ( past : datetime ) -> str : \"\"\"Return the a show slug from a past show.\"\"\" _url = f \" { __ARCHIV_BROADCASTS_URL }{ past . year } / { past . month : 02d } / { past . day : 02d } / { past . hour : 02d }{ past . minute : 02d }{ past . second : 02d } \" # pylint: disable=line-too-long _resp = requests . get ( _url , timeout = 10 ) _json = _resp . json () _data = _json . get ( \"data\" ) _label = str ( _data [ 0 ] . get ( \"attributes\" ) . get ( \"label\" )) return _label . lower () . replace ( \" \" , \"-\" )","title":"past"},{"location":"reference/cridlib/strategy/past/#cridlib.strategy.past.get_show","text":"Return the a show slug from a past show. Source code in cridlib/strategy/past.py 10 11 12 13 14 15 16 17 18 19 def get_show ( past : datetime ) -> str : \"\"\"Return the a show slug from a past show.\"\"\" _url = f \" { __ARCHIV_BROADCASTS_URL }{ past . year } / { past . month : 02d } / { past . day : 02d } / { past . hour : 02d }{ past . minute : 02d }{ past . second : 02d } \" # pylint: disable=line-too-long _resp = requests . get ( _url , timeout = 10 ) _json = _resp . json () _data = _json . get ( \"data\" ) _label = str ( _data [ 0 ] . get ( \"attributes\" ) . get ( \"label\" )) return _label . lower () . replace ( \" \" , \"-\" )","title":"get_show()"}]}