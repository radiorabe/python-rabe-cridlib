{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RaBe cridlib for Python","text":"<p>Generate RaBe CRIDs based on several data sources:</p> <ul> <li>Songticker for current CRID</li> <li><code>archiv.rabe.ch</code> for past CRIDs</li> <li>LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>poetry add rabe-cridlib\n\n# or on old setup style projects\npip -m install rabe-cridlib\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>&gt;&gt;&gt; import cridlib\n&gt;&gt;&gt;\n&gt;&gt;&gt; # parse an existing crid\n&gt;&gt;&gt; crid = cridlib.parse(\"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\")\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}, start: {crid.start}\")\nversion: v1, show: klangbecken, start: 1993-03-01 13:12:00\n&gt;&gt;&gt; # get crid for current show\n&gt;&gt;&gt; crid = cridlib.get()\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}\")  # doctest:+ELLIPSIS\nversion: v1, show: ...\n</code></pre>"},{"location":"#development","title":"Development","text":"<pre><code># setup a dev env\npython -mvenv env\n. env/bin/activate\n\n# install a modern poetry version\npython -mpip install poetry&gt;=1.2.0\n\n# install deps and dev version\npoetry install\n\n# make changes, run tests\npytest\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action <code>semantic-release.yaml</code> in radiorabe/actions that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi.</p>"},{"location":"#license","title":"License","text":"<p>This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2022 Radio Bern RaBe</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cridlib<ul> <li>get</li> <li>lib</li> <li>parse</li> <li>strategy<ul> <li>future</li> <li>now</li> <li>past</li> </ul> </li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/cridlib/","title":"cridlib","text":"<p>Generate RaBe Content Reference Idenitifier Spcification (CRID) Identifiers.</p> <ul> <li><code>cridlib.get(timestamp=None, fragment='')</code></li> <li><code>cridlib.parse(value)</code></li> </ul>"},{"location":"reference/cridlib/get/","title":"get","text":""},{"location":"reference/cridlib/get/#cridlib.get.get","title":"<code>get(timestamp=None, fragment='')</code>","text":"<p>Get a RaBe CRID.</p> <p>Examples:</p> <p>You can get a CRID for a specific time.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from pytz import timezone\n&gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n&gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\nversion: v1, start: ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>Optional[datetime]</code> <p>Exact time you want a CRID for. If left empty, a CRID for the current time is generated.</p> <code>None</code> <code>fragment</code> <code>str</code> <p>Optional fragment to add to the end of the CRID.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>CRID</code> <code>CRID</code> <p>The generated CRID.</p> Source code in <code>cridlib/get.py</code> <pre><code>def get(timestamp: Optional[datetime] = None, fragment: str = \"\") -&gt; CRID:\n\"\"\"Get a RaBe CRID.\n    Examples:\n        You can get a CRID for a specific time.\n        ```python\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from pytz import timezone\n        &gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n        &gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\n        version: v1, start: ...\n        ```\n    Parameters:\n        timestamp: Exact time you want a CRID for.\n            If left empty, a CRID for the current time is generated.\n        fragment: Optional fragment to add to the end of the CRID.\n    Returns:\n        CRID: The generated CRID.\n    \"\"\"\n_now = datetime.now(timezone.utc)\n_ts = timestamp or _now\n_show = \"\"\nif _ts == _now:\n_show = now.get_show()\nelif _ts &lt; _now:\n_show = past.get_show(past=_ts)\nelif _ts &gt; _now:  # pragma: no cover\n_show = future.get_show(future=_ts)\nif _show:\n_show = canonicalize_show(_show)\n_tscode = f\"t=clock={_ts.strftime('%Y%m%dT%H%M%S.%f')[:-4]}Z\"\n_fragment = f\"{_tscode}{'&amp;' + fragment if fragment else ''}\"\nreturn CRID(f\"crid://rabe.ch/v1{'/' + _show if _show else ''}#{_fragment}\")\n</code></pre>"},{"location":"reference/cridlib/lib/","title":"lib","text":""},{"location":"reference/cridlib/lib/#cridlib.lib.CRID","title":"<code>CRID</code>","text":"<p>Represent CRIDs and can parse, validate and render them.</p> <p>Examples:</p> <p>Generate a CRID from an URL and render it's repr: <pre><code>&gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n&lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n</code></pre></p> <p>Generate a CRID and render it as str: <pre><code>&gt;&gt;&gt; str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\"))\n'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'\n</code></pre></p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRID:\n\"\"\"Represent CRIDs and can parse, validate and render them.\n    Examples:\n        Generate a CRID from an URL and render it's repr:\n        ```python\n        &gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n        &lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n        ```\n        Generate a CRID and render it as str:\n        ```python\n        &gt;&gt;&gt; str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\"))\n        'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'\n        ```\n    \"\"\"\ndef __init__(self, uri: Optional[str] = None) -&gt; None:\n\"\"\"\n        Parameters:\n            uri: CRID URL to base the new CRID off of.\n        \"\"\"\nself._show: Optional[str] = None\nself._start: Optional[datetime] = None\nself._uri = urisplit(uri)\nif self.scheme != \"crid\":\nraise CRIDSchemeMismatchError(self.scheme, uri)\nif self.authority != \"rabe.ch\":\nraise CRIDSchemeAuthorityMismatchError(self.authority, uri)\n# parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\nif self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\nraise CRIDUnsupportedVersionError(self.path, uri)\nself._version = self.path.parent.stem or self.path.stem\n# only store show if we have one\nif self.path.stem != \"v1\":\nself._show = self.path.relative_to(self.path.parent).stem\n# fragments are optional, but if provided we want them to contain t=code\nif self.fragment:\ntry:\nself._start = datetime.strptime(\nparse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n\"%Y%m%dT%H%M%S.%fZ\",\n)\nexcept KeyError as ex:\nraise CRIDMissingMediaFragmentError(self.fragment, uri) from ex\nexcept ValueError as ex:  # pragma: no cover\nraise CRIDMalformedMediaFragmentError(self.fragment, uri) from ex\ndef __str__(self) -&gt; str:\n\"\"\"\n        Returns:\n            CRID URL  rendered as string.\n        \"\"\"\nreturn uricompose(*self._uri)\ndef __repr__(self) -&gt; str:\n_fqcn = f\"{self.__class__.__module__}.{self.__class__.__qualname__}\"\nreturn f\"&lt;class '{_fqcn}' for '{str(self)}'&gt;\"\n@property\ndef scheme(self) -&gt; str:\n\"\"\"\n        Returns:\n            Scheme part of the CRID.\n        \"\"\"\nreturn self._uri.scheme\n@property\ndef authority(self) -&gt; str:\n\"\"\"\n        Returns:\n            Authority part (aka hostname) of CRID.\n        \"\"\"\nreturn self._uri.authority\n@property\ndef path(self) -&gt; CRIDPath:\n\"\"\"\n        Returns:\n            Path part of CRID.\n        \"\"\"\nreturn CRIDPath(self._uri.path)\n@property\ndef fragment(self) -&gt; str:\n\"\"\"\n        Returns:\n            Framgment part of CRID.\n        \"\"\"\nreturn self._uri.fragment\n@property\ndef version(self) -&gt; str:\n\"\"\"\n        Returns:\n            Version from CRIDs path.\n        \"\"\"\nreturn self._version\n@property\ndef show(self) -&gt; Optional[str]:\n\"\"\"\n        Returns:\n            Show slug from CRIDs path.\n        \"\"\"\nreturn self._show\n@property\ndef start(self) -&gt; Optional[datetime]:\n\"\"\"\n        Returns:\n            Start time form CRIDs media fragment.\n        \"\"\"\nreturn self._start\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority","title":"<code>authority: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Authority part (aka hostname) of CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment","title":"<code>fragment: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Framgment part of CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path","title":"<code>path: CRIDPath</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>CRIDPath</code> <p>Path part of CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme","title":"<code>scheme: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Scheme part of the CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show","title":"<code>show: Optional[str]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[str]</code> <p>Show slug from CRIDs path.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start","title":"<code>start: Optional[datetime]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Start time form CRIDs media fragment.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Version from CRIDs path.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__init__","title":"<code>__init__(uri=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>uri</code> <code>Optional[str]</code> <p>CRID URL to base the new CRID off of.</p> <code>None</code> Source code in <code>cridlib/lib.py</code> <pre><code>def __init__(self, uri: Optional[str] = None) -&gt; None:\n\"\"\"\n    Parameters:\n        uri: CRID URL to base the new CRID off of.\n    \"\"\"\nself._show: Optional[str] = None\nself._start: Optional[datetime] = None\nself._uri = urisplit(uri)\nif self.scheme != \"crid\":\nraise CRIDSchemeMismatchError(self.scheme, uri)\nif self.authority != \"rabe.ch\":\nraise CRIDSchemeAuthorityMismatchError(self.authority, uri)\n# parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\nif self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\nraise CRIDUnsupportedVersionError(self.path, uri)\nself._version = self.path.parent.stem or self.path.stem\n# only store show if we have one\nif self.path.stem != \"v1\":\nself._show = self.path.relative_to(self.path.parent).stem\n# fragments are optional, but if provided we want them to contain t=code\nif self.fragment:\ntry:\nself._start = datetime.strptime(\nparse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n\"%Y%m%dT%H%M%S.%fZ\",\n)\nexcept KeyError as ex:\nraise CRIDMissingMediaFragmentError(self.fragment, uri) from ex\nexcept ValueError as ex:  # pragma: no cover\nraise CRIDMalformedMediaFragmentError(self.fragment, uri) from ex\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>CRID URL  rendered as string.</p> Source code in <code>cridlib/lib.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Returns:\n        CRID URL  rendered as string.\n    \"\"\"\nreturn uricompose(*self._uri)\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDError","title":"<code>CRIDError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Represent all cridlib errors.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDError(Exception):\n\"\"\"Represent all cridlib errors.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMalformedMediaFragmentError","title":"<code>CRIDMalformedMediaFragmentError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMalformedMediaFragmentError(CRIDError):\n\"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMissingMediaFragmentError","title":"<code>CRIDMissingMediaFragmentError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMissingMediaFragmentError(CRIDError):\n\"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeAuthorityMismatchError","title":"<code>CRIDSchemeAuthorityMismatchError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Hostname part of URI does not match 'rabe.ch'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeAuthorityMismatchError(CRIDError):\n\"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeMismatchError","title":"<code>CRIDSchemeMismatchError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Scheme in URI does not match 'crid'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeMismatchError(CRIDError):\n\"\"\"Scheme in URI does not match 'crid'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDUnsupportedVersionError","title":"<code>CRIDUnsupportedVersionError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Unsupported version in path of URI.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDUnsupportedVersionError(CRIDError):\n\"\"\"Unsupported version in path of URI.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.canonicalize_show","title":"<code>canonicalize_show(show)</code>","text":"<p>Get the slug for a show using python-slugify.</p> <p>Parameters:</p> Name Type Description Default <code>show</code> <code>str</code> <p>Name of show with non-ascii chars.</p> required <p>Returns:</p> Type Description <code>str</code> <p>slugified show name.</p> Source code in <code>cridlib/lib.py</code> <pre><code>def canonicalize_show(show: str) -&gt; str:\n\"\"\"Get the slug for a show using [python-slugify](https://github.com/un33k/python-slugify).\n    Parameters:\n        show: Name of show with non-ascii chars.\n    Returns:\n        slugified show name.\n    \"\"\"\nreturn slugify(show)\n</code></pre>"},{"location":"reference/cridlib/parse/","title":"parse","text":""},{"location":"reference/cridlib/parse/#cridlib.parse.parse","title":"<code>parse(value)</code>","text":"<p>Get CRID dataclass from CRID.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>CRID URL as a string.</p> required <p>Returns:</p> Name Type Description <code>CRID</code> <code>CRID</code> <p>The parsed CRID.</p> Source code in <code>cridlib/parse.py</code> <pre><code>def parse(value: str) -&gt; CRID:\n\"\"\"Get CRID dataclass from CRID.\n    Parameters:\n        value: CRID URL as a string.\n    Returns:\n        CRID: The parsed CRID.\n    \"\"\"\nreturn CRID(value)\n</code></pre>"},{"location":"reference/cridlib/util/","title":"util","text":""},{"location":"reference/cridlib/util/#cridlib.util.get_session","title":"<code>get_session(retries=5, backoff_factor=0.1)</code>","text":"<p>Get a requests session with retry/backoff.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>How often to retry.</p> <code>5</code> <code>backoff_factor</code> <code>float</code> <p>A backoff factor to apply between attempts after the second try (most errors are resolved immediately by a second try without a delay). urllib3 will sleep for::     {backoff factor} * (2 ** ({number of total retries} - 1)) seconds. If the backoff_factor is 0.1, then :func:<code>Retry.sleep</code> will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer than <code>backoff_max</code>. By default, backoff is set to 0.1.</p> <code>0.1</code> Source code in <code>cridlib/util.py</code> <pre><code>def get_session(\nretries: int = 5,\nbackoff_factor: float = 0.1,\n) -&gt; Session:\n\"\"\"Get a requests session with retry/backoff.\n    Parameters:\n        retries: How often to retry.\n        backoff_factor: A backoff factor to apply between attempts after the\n            second try (most errors are resolved immediately by a second try\n            without a delay). urllib3 will sleep for::\n                {backoff factor} * (2 ** ({number of total retries} - 1))\n            seconds. If the backoff_factor is 0.1, then :func:`Retry.sleep`\n            will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will\n            never be longer than `backoff_max`.\n            By default, backoff is set to 0.1.\n    \"\"\"\nsession = Session()\nsession.mount(\n\"https://\",\nHTTPAdapter(\nmax_retries=Retry(\ntotal=retries,\nbackoff_factor=backoff_factor,\n)\n),\n)\nreturn session\n</code></pre>"},{"location":"reference/cridlib/strategy/","title":"strategy","text":"<p>Different strategies for getting CRIDs from different sources.</p> <ul> <li><code>cridlib.strategy.past</code></li> <li><code>cridlib.strategy.present</code></li> <li><code>cridlib.strategy.future</code></li> </ul>"},{"location":"reference/cridlib/strategy/future/","title":"future","text":""},{"location":"reference/cridlib/strategy/future/#cridlib.strategy.future.get_show","title":"<code>get_show(future)</code>","text":"<p>Return the slug for a show from LibreTime if it is in the next 7 days.</p> <p>Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023.</p> <p>Parameters:</p> Name Type Description Default <code>future</code> <code>datetime</code> <p>Date to get the show name for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name of the show scheduled for <code>future</code>.</p> Source code in <code>cridlib/strategy/future.py</code> <pre><code>def get_show(future: datetime) -&gt; str:  # pragma: no cover\n\"\"\"Return the slug for a show from LibreTime if it is in the next 7 days.\n    Only returns a show for the next seven days because everything futher than\n    that is considered unreliable as of early 2023.\n    Parameters:\n        future: Date to get the show name for.\n    Returns:\n        Name of the show scheduled for `future`.\n    \"\"\"\n_resp = get_session().get(\n__LIBRETIME_INFOV2_URL,\nparams={\n\"days\": 7,\n\"shows\": 7000,\n},\ntimeout=10,\n)\n_json = _resp.json()\n_tz = _json.get(\"station\").get(\"timezone\")\n_next = _json.get(\"shows\").get(\"next\")\nfor _show in _next:\n_start = datetime.fromisoformat(_show.get(\"starts\")).replace(\ntzinfo=timezone.utc\n)\n_end = datetime.fromisoformat(_show.get(\"ends\")).replace(tzinfo=timezone.utc)\nif _start &lt;= future &lt;= _end:\n_path = PurePath(urisplit(_show.get(\"url\")).path)\nreturn _path.stem\nreturn \"\"\n</code></pre>"},{"location":"reference/cridlib/strategy/now/","title":"now","text":""},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show","title":"<code>get_show()</code>","text":"<p>Return the currently running show.</p> <p>Calls the the nowplaying songticker's API.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the currently running show.</p> Source code in <code>cridlib/strategy/now.py</code> <pre><code>def get_show() -&gt; str:\n\"\"\"Return the currently running show.\n    Calls the the [nowplaying](https://github.com/radiorabe/nowplaying) songticker's API.\n    Returns:\n        Name of the currently running show.\n    \"\"\"\n_resp = get_session().get(__SONGTICKER_URL, timeout=10)\n_tree = ET.fromstring(_resp.text)\n_path = PurePath(urisplit(_tree[3][1].text).path)\nreturn _path.stem\n</code></pre>"},{"location":"reference/cridlib/strategy/past/","title":"past","text":""},{"location":"reference/cridlib/strategy/past/#cridlib.strategy.past.get_show","title":"<code>get_show(past)</code>","text":"<p>Return a show from the past.</p> <p>Asks the the raar archive for the info.</p> <p>Parameters:</p> Name Type Description Default <code>past</code> <code>datetime</code> <p>Date to get the show name for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Show name from the archive for <code>past</code>.</p> Source code in <code>cridlib/strategy/past.py</code> <pre><code>def get_show(past: datetime) -&gt; str:\n\"\"\"Return a show from the past.\n    Asks the the [raar](https://github.com/radiorabe/raar) archive for the info.\n    Parameters:\n        past: Date to get the show name for.\n    Returns:\n        Show name from the archive for `past`.\n    \"\"\"\n_url = f\"{__ARCHIV_BROADCASTS_URL}{past.year}/{past.month:02d}/{past.day:02d}/{past.hour:02d}{past.minute:02d}{past.second:02d}\"  # pylint: disable=line-too-long\n_resp = get_session().get(_url, timeout=10)\n_json = _resp.json()\n_data = _json.get(\"data\")\n_label = str(_data[0].get(\"attributes\").get(\"label\"))\nreturn _label.lower().replace(\" \", \"-\")\n</code></pre>"}]}