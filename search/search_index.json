{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RaBe cridlib for Python","text":"<p>Generate RaBe CRIDs based on several data sources:</p> <ul> <li>Songticker for current CRID</li> <li><code>archiv.rabe.ch</code> for past CRIDs</li> <li>LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>poetry add rabe-cridlib\n\n# or on old setup style projects\npip -m install rabe-cridlib\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>&gt;&gt;&gt; import cridlib\n&gt;&gt;&gt;\n&gt;&gt;&gt; # parse an existing crid\n&gt;&gt;&gt; crid = cridlib.parse(\"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\")\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}, start: {crid.start}\")\nversion: v1, show: klangbecken, start: 1993-03-01 13:12:00\n\n&gt;&gt;&gt; # get crid for current show\n&gt;&gt;&gt; crid = cridlib.get()\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}\")  # doctest:+ELLIPSIS\nversion: v1, show: ...\n</code></pre>"},{"location":"#development","title":"Development","text":"<pre><code># setup a dev env\npython -mvenv env\n. env/bin/activate\n\n# install a modern poetry version\npython -mpip install poetry&gt;=1.2.0\n\n# install deps and dev version\npoetry install\n\n# make changes, run tests\npytest\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action <code>semantic-release.yaml</code> in radiorabe/actions that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi.</p>"},{"location":"#license","title":"License","text":"<p>This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2022 Radio Bern RaBe</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cridlib<ul> <li>get</li> <li>lib</li> <li>parse</li> <li>strategy<ul> <li>future</li> <li>now</li> <li>past</li> </ul> </li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/cridlib/","title":"cridlib","text":"<p>Generate RaBe Content Reference Idenitifier Spcification (CRID) Identifiers.</p> <ul> <li><code>cridlib.get(timestamp=None, fragment='')</code></li> <li><code>cridlib.parse(value)</code></li> </ul>"},{"location":"reference/cridlib/#cridlib.CRIDError","title":"<code>CRIDError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Represent all cridlib errors.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDError(Exception):\n    \"\"\"Represent all cridlib errors.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/get/","title":"get","text":"<p>Get a RaBe CRID.</p>"},{"location":"reference/cridlib/get/#cridlib.get.get","title":"<code>get(timestamp=None, fragment='')</code>","text":"<p>Get a RaBe CRID.</p> <p>Examples:</p> <pre><code>You can get a CRID for a specific time.\n\n```python\n&gt;&gt;&gt; from unittest.mock import MagicMock, patch\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from pytz import timezone\n&gt;&gt;&gt; mock_resp = MagicMock()\n&gt;&gt;&gt; mock_show_data = {\"data\": [{\"attributes\": {\"label\": \"Klangbecken\"}}]}\n&gt;&gt;&gt; mock_resp.json.return_value = mock_show_data\n&gt;&gt;&gt; # 2020-03-01 is in the past; patch the archive strategy to stay offline\n&gt;&gt;&gt; with patch(\"cridlib.strategy.past.get_session\") as mock_gs:\n...     mock_gs.return_value.get.return_value = mock_resp\n...     crid = get(datetime(2020, 3, 1, 0, 0, tzinfo=timezone('Europe/Zurich')))\n&gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\nversion: v1, start: ...\n\n```\n</code></pre> <pre><code>timestamp: Exact time you want a CRID for.\n    If left empty, a CRID for the current time is generated.\nfragment: Optional fragment to add to the end of the CRID.\n</code></pre> <pre><code>CRID: The generated CRID.\n</code></pre> Source code in <code>cridlib/get.py</code> <pre><code>def get(timestamp: datetime | None = None, fragment: str = \"\") -&gt; CRID:\n    \"\"\"Get a RaBe CRID.\n\n    Examples:\n    --------\n        You can get a CRID for a specific time.\n\n        ```python\n        &gt;&gt;&gt; from unittest.mock import MagicMock, patch\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from pytz import timezone\n        &gt;&gt;&gt; mock_resp = MagicMock()\n        &gt;&gt;&gt; mock_show_data = {\"data\": [{\"attributes\": {\"label\": \"Klangbecken\"}}]}\n        &gt;&gt;&gt; mock_resp.json.return_value = mock_show_data\n        &gt;&gt;&gt; # 2020-03-01 is in the past; patch the archive strategy to stay offline\n        &gt;&gt;&gt; with patch(\"cridlib.strategy.past.get_session\") as mock_gs:\n        ...     mock_gs.return_value.get.return_value = mock_resp\n        ...     crid = get(datetime(2020, 3, 1, 0, 0, tzinfo=timezone('Europe/Zurich')))\n        &gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\n        version: v1, start: ...\n\n        ```\n\n    Args:\n    ----\n        timestamp: Exact time you want a CRID for.\n            If left empty, a CRID for the current time is generated.\n        fragment: Optional fragment to add to the end of the CRID.\n\n    Returns:\n    -------\n        CRID: The generated CRID.\n\n    \"\"\"\n    _now = datetime.now(timezone.utc)\n    _ts = timestamp or _now\n    _show = \"\"\n    if _ts == _now:\n        _show = now.get_show()\n    elif _ts &lt; _now:\n        _show = past.get_show(past=_ts)\n    elif _ts &gt; _now:  # pragma: no cover\n        _show = future.get_show(future=_ts)\n\n    if _show:\n        _show = canonicalize_show(_show)\n\n    _tscode = f\"t=clock={_ts.strftime('%Y%m%dT%H%M%S.%f')[:-4]}Z\"\n    _fragment = f\"{_tscode}{'&amp;' + fragment if fragment else ''}\"\n\n    return CRID(f\"crid://rabe.ch/v1{'/' + _show if _show else ''}#{_fragment}\")\n</code></pre>"},{"location":"reference/cridlib/lib/","title":"lib","text":"<p>Main Cridlib library.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID","title":"<code>CRID</code>","text":"<p>Represent CRIDs and can parse, validate and render them.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID--examples","title":"Examples","text":"<pre><code>Generate a CRID from an URL and render it's repr:\n```python\n&gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n&lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n\n```\n\nGenerate a CRID and render it as str:\n```python\n&gt;&gt;&gt; str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\"))\n'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'\n\n```\n</code></pre> Source code in <code>cridlib/lib.py</code> <pre><code>class CRID:\n    \"\"\"Represent CRIDs and can parse, validate and render them.\n\n    Examples\n    --------\n        Generate a CRID from an URL and render it's repr:\n        ```python\n        &gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n        &lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n\n        ```\n\n        Generate a CRID and render it as str:\n        ```python\n        &gt;&gt;&gt; str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\"))\n        'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'\n\n        ```\n\n    \"\"\"\n\n    def __init__(self: Self, uri: str | None = None) -&gt; None:\n        \"\"\"Create new CRID.\n\n        Args:\n        ----\n            uri: CRID URL to base the new CRID off of.\n\n        \"\"\"\n        self._show: str | None = None\n        self._start: datetime | None = None\n\n        self._uri = urisplit(uri)\n        if self.scheme != \"crid\":\n            raise CRIDSchemeMismatchError(self.scheme, uri)\n        if self.authority != \"rabe.ch\":\n            raise CRIDSchemeAuthorityMismatchError(self.authority, uri)\n        # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\n        if self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\n            raise CRIDUnsupportedVersionError(self.path, uri)\n        self._version = self.path.parent.stem or self.path.stem\n        # only store show if we have one\n        if self.path.stem != \"v1\":\n            self._show = self.path.relative_to(self.path.parent).stem\n        # fragments are optional, but if provided we want them to contain t=code\n        if self.fragment:\n            try:\n                # TODO(hairmare): investigate noqa for bug\n                # https://github.com/radiorabe/python-rabe-cridlib/issues/244\n                self._start = datetime.strptime(  # noqa: DTZ007\n                    parse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n                    \"%Y%m%dT%H%M%S.%fZ\",\n                )\n            except KeyError as ex:\n                raise CRIDMissingMediaFragmentError(self.fragment, uri) from ex\n            except ValueError as ex:  # pragma: no cover\n                raise CRIDMalformedMediaFragmentError(self.fragment, uri) from ex\n\n    def __str__(self: Self) -&gt; str:\n        \"\"\"Stringfy.\n\n        Returns\n        -------\n            CRID URL rendered as string.\n\n        \"\"\"\n        return uricompose(*self._uri)\n\n    def __repr__(self: Self) -&gt; str:\n        \"\"\"Repr.\"\"\"\n        _fqcn = f\"{self.__class__.__module__}.{self.__class__.__qualname__}\"\n        return f\"&lt;class '{_fqcn}' for '{self!s}'&gt;\"\n\n    @property\n    def scheme(self: Self) -&gt; str:\n        \"\"\"Scheme.\n\n        Returns\n        -------\n            Scheme part of the CRID.\n\n        \"\"\"\n        return self._uri.scheme\n\n    @property\n    def authority(self: Self) -&gt; str:\n        \"\"\"Authority.\n\n        Returns\n        -------\n            Authority part (aka hostname) of CRID.\n\n        \"\"\"\n        return self._uri.authority\n\n    @property\n    def path(self: Self) -&gt; CRIDPath:\n        \"\"\"Path.\n\n        Returns\n        -------\n            Path part of CRID.\n\n        \"\"\"\n        return CRIDPath(self._uri.path)\n\n    @property\n    def fragment(self: Self) -&gt; str:\n        \"\"\"Fragment.\n\n        Returns\n        -------\n            Fragment part of CRID.\n\n        \"\"\"\n        return self._uri.fragment\n\n    @property\n    def version(self: Self) -&gt; str:\n        \"\"\"Version.\n\n        Returns\n        -------\n            Version from CRIDs path.\n\n        \"\"\"\n        return self._version\n\n    @property\n    def show(self: Self) -&gt; str | None:\n        \"\"\"Slug.\n\n        Returns\n        -------\n            Show slug from CRIDs path.\n\n        \"\"\"\n        return self._show\n\n    @property\n    def start(self: Self) -&gt; datetime | None:\n        \"\"\"Start time.\n\n        Returns\n        -------\n            Start time form CRIDs media fragment.\n\n        \"\"\"\n        return self._start\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority","title":"<code>authority</code>  <code>property</code>","text":"<p>Authority.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority--returns","title":"Returns","text":"<pre><code>Authority part (aka hostname) of CRID.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment","title":"<code>fragment</code>  <code>property</code>","text":"<p>Fragment.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment--returns","title":"Returns","text":"<pre><code>Fragment part of CRID.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path","title":"<code>path</code>  <code>property</code>","text":"<p>Path.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path--returns","title":"Returns","text":"<pre><code>Path part of CRID.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme","title":"<code>scheme</code>  <code>property</code>","text":"<p>Scheme.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme--returns","title":"Returns","text":"<pre><code>Scheme part of the CRID.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show","title":"<code>show</code>  <code>property</code>","text":"<p>Slug.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show--returns","title":"Returns","text":"<pre><code>Show slug from CRIDs path.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start","title":"<code>start</code>  <code>property</code>","text":"<p>Start time.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start--returns","title":"Returns","text":"<pre><code>Start time form CRIDs media fragment.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version","title":"<code>version</code>  <code>property</code>","text":"<p>Version.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version--returns","title":"Returns","text":"<pre><code>Version from CRIDs path.\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__init__","title":"<code>__init__(uri=None)</code>","text":"<p>Create new CRID.</p> <pre><code>uri: CRID URL to base the new CRID off of.\n</code></pre> Source code in <code>cridlib/lib.py</code> <pre><code>def __init__(self: Self, uri: str | None = None) -&gt; None:\n    \"\"\"Create new CRID.\n\n    Args:\n    ----\n        uri: CRID URL to base the new CRID off of.\n\n    \"\"\"\n    self._show: str | None = None\n    self._start: datetime | None = None\n\n    self._uri = urisplit(uri)\n    if self.scheme != \"crid\":\n        raise CRIDSchemeMismatchError(self.scheme, uri)\n    if self.authority != \"rabe.ch\":\n        raise CRIDSchemeAuthorityMismatchError(self.authority, uri)\n    # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\n    if self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\n        raise CRIDUnsupportedVersionError(self.path, uri)\n    self._version = self.path.parent.stem or self.path.stem\n    # only store show if we have one\n    if self.path.stem != \"v1\":\n        self._show = self.path.relative_to(self.path.parent).stem\n    # fragments are optional, but if provided we want them to contain t=code\n    if self.fragment:\n        try:\n            # TODO(hairmare): investigate noqa for bug\n            # https://github.com/radiorabe/python-rabe-cridlib/issues/244\n            self._start = datetime.strptime(  # noqa: DTZ007\n                parse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n                \"%Y%m%dT%H%M%S.%fZ\",\n            )\n        except KeyError as ex:\n            raise CRIDMissingMediaFragmentError(self.fragment, uri) from ex\n        except ValueError as ex:  # pragma: no cover\n            raise CRIDMalformedMediaFragmentError(self.fragment, uri) from ex\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr.</p> Source code in <code>cridlib/lib.py</code> <pre><code>def __repr__(self: Self) -&gt; str:\n    \"\"\"Repr.\"\"\"\n    _fqcn = f\"{self.__class__.__module__}.{self.__class__.__qualname__}\"\n    return f\"&lt;class '{_fqcn}' for '{self!s}'&gt;\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__str__","title":"<code>__str__()</code>","text":"<p>Stringfy.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__str__--returns","title":"Returns","text":"<pre><code>CRID URL rendered as string.\n</code></pre> Source code in <code>cridlib/lib.py</code> <pre><code>def __str__(self: Self) -&gt; str:\n    \"\"\"Stringfy.\n\n    Returns\n    -------\n        CRID URL rendered as string.\n\n    \"\"\"\n    return uricompose(*self._uri)\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDError","title":"<code>CRIDError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Represent all cridlib errors.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDError(Exception):\n    \"\"\"Represent all cridlib errors.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMalformedMediaFragmentError","title":"<code>CRIDMalformedMediaFragmentError</code>","text":"<p>               Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMalformedMediaFragmentError(CRIDError):\n    \"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMissingMediaFragmentError","title":"<code>CRIDMissingMediaFragmentError</code>","text":"<p>               Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMissingMediaFragmentError(CRIDError):\n    \"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeAuthorityMismatchError","title":"<code>CRIDSchemeAuthorityMismatchError</code>","text":"<p>               Bases: <code>CRIDError</code></p> <p>Hostname part of URI does not match 'rabe.ch'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeAuthorityMismatchError(CRIDError):\n    \"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeMismatchError","title":"<code>CRIDSchemeMismatchError</code>","text":"<p>               Bases: <code>CRIDError</code></p> <p>Scheme in URI does not match 'crid'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeMismatchError(CRIDError):\n    \"\"\"Scheme in URI does not match 'crid'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDUnsupportedVersionError","title":"<code>CRIDUnsupportedVersionError</code>","text":"<p>               Bases: <code>CRIDError</code></p> <p>Unsupported version in path of URI.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDUnsupportedVersionError(CRIDError):\n    \"\"\"Unsupported version in path of URI.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.canonicalize_show","title":"<code>canonicalize_show(show)</code>","text":"<p>Get the slug for a show.</p> <p>Uses python-slugify.</p> <pre><code>show: Name of show with non-ascii chars.\n</code></pre> <pre><code>slugified show name.\n</code></pre> Source code in <code>cridlib/lib.py</code> <pre><code>def canonicalize_show(show: str) -&gt; str:\n    \"\"\"Get the slug for a show.\n\n    Uses [python-slugify](https://github.com/un33k/python-slugify).\n\n    Args:\n    ----\n        show: Name of show with non-ascii chars.\n\n    Returns:\n    -------\n        slugified show name.\n\n    \"\"\"\n    return slugify(show)\n</code></pre>"},{"location":"reference/cridlib/parse/","title":"parse","text":"<p>Parse an existing CRID.</p>"},{"location":"reference/cridlib/parse/#cridlib.parse.parse","title":"<code>parse(value)</code>","text":"<p>Get CRID dataclass from CRID.</p> <pre><code>value: CRID URL as a string.\n</code></pre> <pre><code>CRID: The parsed CRID.\n</code></pre> Source code in <code>cridlib/parse.py</code> <pre><code>def parse(value: str) -&gt; CRID:\n    \"\"\"Get CRID dataclass from CRID.\n\n    Args:\n    ----\n        value: CRID URL as a string.\n\n    Returns:\n    -------\n        CRID: The parsed CRID.\n\n    \"\"\"\n    return CRID(value)\n</code></pre>"},{"location":"reference/cridlib/util/","title":"util","text":"<p>Utility functions for cridlib.</p>"},{"location":"reference/cridlib/util/#cridlib.util.get_session","title":"<code>get_session(retries=5, backoff_factor=0.1)</code>","text":"<p>Get a requests session with retry/backoff.</p> <pre><code>retries: How often to retry.\nbackoff_factor: A backoff factor to apply between attempts after the\n    second try (most errors are resolved immediately by a second try\n    without a delay). urllib3 will sleep for::\n        {backoff factor} * (2 ** ({number of total retries} - 1))\n    seconds. If the backoff_factor is 0.1, then :func:`Retry.sleep`\n    will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will\n    never be longer than `backoff_max`.\n    By default, backoff is set to 0.1.\n</code></pre> Source code in <code>cridlib/util.py</code> <pre><code>def get_session(\n    retries: int = 5,\n    backoff_factor: float = 0.1,\n) -&gt; Session:\n    \"\"\"Get a requests session with retry/backoff.\n\n    Args:\n    ----\n        retries: How often to retry.\n        backoff_factor: A backoff factor to apply between attempts after the\n            second try (most errors are resolved immediately by a second try\n            without a delay). urllib3 will sleep for::\n                {backoff factor} * (2 ** ({number of total retries} - 1))\n            seconds. If the backoff_factor is 0.1, then :func:`Retry.sleep`\n            will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will\n            never be longer than `backoff_max`.\n            By default, backoff is set to 0.1.\n\n    \"\"\"\n    session = Session()\n    session.mount(\n        \"https://\",\n        HTTPAdapter(\n            max_retries=Retry(\n                total=retries,\n                backoff_factor=backoff_factor,\n            ),\n        ),\n    )\n    return session\n</code></pre>"},{"location":"reference/cridlib/strategy/","title":"strategy","text":"<p>Different strategies for getting CRIDs from different sources.</p> <ul> <li><code>cridlib.strategy.past</code></li> <li><code>cridlib.strategy.present</code></li> <li><code>cridlib.strategy.future</code></li> </ul>"},{"location":"reference/cridlib/strategy/future/","title":"future","text":"<p>Handle shows in the future.</p>"},{"location":"reference/cridlib/strategy/future/#cridlib.strategy.future.get_show","title":"<code>get_show(future)</code>","text":"<p>Return the slug for a show from LibreTime if it is in the next 7 days.</p> <p>Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023.</p> <pre><code>future: Date to get the show name for.\n</code></pre> <pre><code>Name of the show scheduled for `future`.\n</code></pre> Source code in <code>cridlib/strategy/future.py</code> <pre><code>def get_show(future: datetime) -&gt; str:  # pragma: no cover\n    \"\"\"Return the slug for a show from LibreTime if it is in the next 7 days.\n\n    Only returns a show for the next seven days because everything futher than\n    that is considered unreliable as of early 2023.\n\n    Args:\n    ----\n        future: Date to get the show name for.\n\n    Returns:\n    -------\n        Name of the show scheduled for `future`.\n\n    \"\"\"\n    _resp = get_session().get(\n        __LIBRETIME_INFOV2_URL,\n        params={\n            \"days\": 7,\n            \"shows\": 7000,\n        },\n        timeout=10,\n    )\n\n    _json = _resp.json()\n    _tz = _json.get(\"station\").get(\"timezone\")\n    _next = _json.get(\"shows\").get(\"next\")\n    for _show in _next:\n        _start = datetime.fromisoformat(_show.get(\"starts\")).replace(\n            tzinfo=timezone.utc,\n        )\n        _end = datetime.fromisoformat(_show.get(\"ends\")).replace(tzinfo=timezone.utc)\n        if _start &lt;= future &lt;= _end:\n            _path = PurePath(urisplit(_show.get(\"url\")).path)\n            return _path.stem\n\n    return \"\"\n</code></pre>"},{"location":"reference/cridlib/strategy/now/","title":"now","text":"<p>Handle currently running show.</p>"},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show","title":"<code>get_show()</code>","text":"<p>Get the currently running show.</p> <p>Calls the the nowplaying songticker's API.</p>"},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show--returns","title":"Returns","text":"<pre><code>Name of the currently running show.\n</code></pre> Source code in <code>cridlib/strategy/now.py</code> <pre><code>def get_show() -&gt; str:\n    \"\"\"Get the currently running show.\n\n    Calls the the [nowplaying](https://github.com/radiorabe/nowplaying)\n    songticker's API.\n\n    Returns\n    -------\n        Name of the currently running show.\n\n    \"\"\"\n    _resp = get_session().get(__SONGTICKER_URL, timeout=10)\n    _tree = ET.fromstring(_resp.text)  # noqa: S314\n    _path = PurePath(urisplit(_tree[3][1].text).path)\n    return _path.stem\n</code></pre>"},{"location":"reference/cridlib/strategy/past/","title":"past","text":"<p>Handle shows from the past.</p>"},{"location":"reference/cridlib/strategy/past/#cridlib.strategy.past.get_show","title":"<code>get_show(past)</code>","text":"<p>Return a show from the past.</p> <p>Asks the the raar archive for the info.</p> <p>We always request the show info in Europe/Zurich timezone, as the archive works with local times.</p> <pre><code>past: Date to get the show name for.\n</code></pre> <pre><code>Show name from the archive for `past`.\n</code></pre> Source code in <code>cridlib/strategy/past.py</code> <pre><code>def get_show(past: datetime) -&gt; str:\n    \"\"\"Return a show from the past.\n\n    Asks the the [raar](https://github.com/radiorabe/raar) archive for the info.\n\n    We always request the show info in Europe/Zurich timezone, as the archive\n    works with local times.\n\n    Args:\n    ----\n        past: Date to get the show name for.\n\n    Returns:\n    -------\n        Show name from the archive for `past`.\n\n    \"\"\"\n    _past = past.astimezone(tz=ZoneInfo(\"Europe/Zurich\"))\n    _url = f\"{__ARCHIV_BROADCASTS_URL}{_past.year}/{_past.month:02d}/{_past.day:02d}/{_past.hour:02d}{_past.minute:02d}{_past.second:02d}\"  # noqa: E501\n    _resp = get_session().get(_url, timeout=10)\n    _json = _resp.json()\n    _data = _json.get(\"data\")\n    _label = str(_data[0].get(\"attributes\").get(\"label\")) if len(_data) == 1 else \"\"\n\n    return _label.lower().replace(\" \", \"-\")\n</code></pre>"}]}