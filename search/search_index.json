{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RaBe cridlib for Python","text":"<p>Generate RaBe CRIDs based on several data sources:</p> <ul> <li>Songticker for current CRID</li> <li><code>archiv.rabe.ch</code> for past CRIDs</li> <li>LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>poetry add rabe-cridlib\n\n# or on old setup style projects\npip -m install rabe-cridlib\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>&gt;&gt;&gt; import cridlib\n&gt;&gt;&gt;\n&gt;&gt;&gt; # parse an existing crid\n&gt;&gt;&gt; crid = cridlib.parse(\"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\")\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}, start: {crid.start}\")\nversion: v1, show: klangbecken, start: 1993-03-01 13:12:00\n\n&gt;&gt;&gt; # get crid for current show\n&gt;&gt;&gt; crid = cridlib.get()\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}\")  # doctest:+ELLIPSIS\nversion: v1, show: ...\n</code></pre>"},{"location":"#development","title":"Development","text":"<pre><code># setup a dev env\npython -mvenv env\n. env/bin/activate\n\n# install a modern poetry version\npython -mpip install poetry&gt;=1.2.0\n\n# install deps and dev version\npoetry install\n\n# make changes, run tests\npytest\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action <code>semantic-release.yaml</code> in radiorabe/actions that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi.</p>"},{"location":"#license","title":"License","text":"<p>This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2022 Radio Bern RaBe</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cridlib<ul> <li>get</li> <li>lib</li> <li>parse</li> <li>strategy<ul> <li>future</li> <li>now</li> <li>past</li> </ul> </li> <li>util</li> </ul> </li> </ul>"},{"location":"reference/cridlib/","title":"cridlib","text":"<p>Generate RaBe Content Reference Idenitifier Spcification (CRID) Identifiers.</p> <ul> <li><code>cridlib.get(timestamp=None, fragment='')</code></li> <li><code>cridlib.parse(value)</code></li> </ul>"},{"location":"reference/cridlib/#cridlib.CRIDError","title":"<code>CRIDError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Represent all cridlib errors.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDError(Exception):\n    \"\"\"Represent all cridlib errors.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/get/","title":"get","text":""},{"location":"reference/cridlib/get/#cridlib.get.get","title":"<code>get(timestamp=None, fragment='')</code>","text":"<p>Get a RaBe CRID.</p> <p>Examples:</p> <p>You can get a CRID for a specific time.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from pytz import timezone\n&gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n&gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\nversion: v1, start: ...\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>Optional[datetime]</code> <p>Exact time you want a CRID for. If left empty, a CRID for the current time is generated.</p> <code>None</code> <code>fragment</code> <code>str</code> <p>Optional fragment to add to the end of the CRID.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>CRID</code> <code>CRID</code> <p>The generated CRID.</p> Source code in <code>cridlib/get.py</code> <pre><code>def get(timestamp: Optional[datetime] = None, fragment: str = \"\") -&gt; CRID:\n    \"\"\"Get a RaBe CRID.\n\n    Examples:\n        You can get a CRID for a specific time.\n\n        ```python\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; from pytz import timezone\n        &gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n        &gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\n        version: v1, start: ...\n\n        ```\n\n    Parameters:\n        timestamp: Exact time you want a CRID for.\n            If left empty, a CRID for the current time is generated.\n        fragment: Optional fragment to add to the end of the CRID.\n\n    Returns:\n        CRID: The generated CRID.\n    \"\"\"\n    _now = datetime.now(timezone.utc)\n    _ts = timestamp or _now\n    _show = \"\"\n    if _ts == _now:\n        _show = now.get_show()\n    elif _ts &lt; _now:\n        _show = past.get_show(past=_ts)\n    elif _ts &gt; _now:  # pragma: no cover\n        _show = future.get_show(future=_ts)\n\n    if _show:\n        _show = canonicalize_show(_show)\n\n    _tscode = f\"t=clock={_ts.strftime('%Y%m%dT%H%M%S.%f')[:-4]}Z\"\n    _fragment = f\"{_tscode}{'&amp;' + fragment if fragment else ''}\"\n\n    return CRID(f\"crid://rabe.ch/v1{'/' + _show if _show else ''}#{_fragment}\")\n</code></pre>"},{"location":"reference/cridlib/lib/","title":"lib","text":""},{"location":"reference/cridlib/lib/#cridlib.lib.CRID","title":"<code>CRID</code>","text":"<p>Represent CRIDs and can parse, validate and render them.</p> <p>Examples:</p> <p>Generate a CRID from an URL and render it's repr: <pre><code>&gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n&lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n</code></pre></p> <p>Generate a CRID and render it as str: <pre><code>&gt;&gt;&gt; str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\"))\n'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'\n</code></pre></p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRID:\n    \"\"\"Represent CRIDs and can parse, validate and render them.\n\n    Examples:\n        Generate a CRID from an URL and render it's repr:\n        ```python\n        &gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n        &lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n\n        ```\n\n        Generate a CRID and render it as str:\n        ```python\n        &gt;&gt;&gt; str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\"))\n        'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'\n\n        ```\n    \"\"\"  # noqa: E501\n\n    def __init__(self, uri: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Parameters:\n            uri: CRID URL to base the new CRID off of.\n        \"\"\"\n        self._show: Optional[str] = None\n        self._start: Optional[datetime] = None\n\n        self._uri = urisplit(uri)\n        if self.scheme != \"crid\":\n            raise CRIDSchemeMismatchError(self.scheme, uri)\n        if self.authority != \"rabe.ch\":\n            raise CRIDSchemeAuthorityMismatchError(self.authority, uri)\n        # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\n        if self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\n            raise CRIDUnsupportedVersionError(self.path, uri)\n        self._version = self.path.parent.stem or self.path.stem\n        # only store show if we have one\n        if self.path.stem != \"v1\":\n            self._show = self.path.relative_to(self.path.parent).stem\n        # fragments are optional, but if provided we want them to contain t=code\n        if self.fragment:\n            try:\n                self._start = datetime.strptime(\n                    parse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n                    \"%Y%m%dT%H%M%S.%fZ\",\n                )\n            except KeyError as ex:\n                raise CRIDMissingMediaFragmentError(self.fragment, uri) from ex\n            except ValueError as ex:  # pragma: no cover\n                raise CRIDMalformedMediaFragmentError(self.fragment, uri) from ex\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns:\n            CRID URL  rendered as string.\n        \"\"\"\n        return uricompose(*self._uri)\n\n    def __repr__(self) -&gt; str:\n        _fqcn = f\"{self.__class__.__module__}.{self.__class__.__qualname__}\"\n        return f\"&lt;class '{_fqcn}' for '{str(self)}'&gt;\"\n\n    @property\n    def scheme(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Scheme part of the CRID.\n        \"\"\"\n        return self._uri.scheme\n\n    @property\n    def authority(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Authority part (aka hostname) of CRID.\n        \"\"\"\n        return self._uri.authority\n\n    @property\n    def path(self) -&gt; CRIDPath:\n        \"\"\"\n        Returns:\n            Path part of CRID.\n        \"\"\"\n        return CRIDPath(self._uri.path)\n\n    @property\n    def fragment(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Framgment part of CRID.\n        \"\"\"\n        return self._uri.fragment\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"\n        Returns:\n            Version from CRIDs path.\n        \"\"\"\n        return self._version\n\n    @property\n    def show(self) -&gt; Optional[str]:\n        \"\"\"\n        Returns:\n            Show slug from CRIDs path.\n        \"\"\"\n        return self._show\n\n    @property\n    def start(self) -&gt; Optional[datetime]:\n        \"\"\"\n        Returns:\n            Start time form CRIDs media fragment.\n        \"\"\"\n        return self._start\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority","title":"<code>authority: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Authority part (aka hostname) of CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment","title":"<code>fragment: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Framgment part of CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path","title":"<code>path: CRIDPath</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>CRIDPath</code> <p>Path part of CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme","title":"<code>scheme: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Scheme part of the CRID.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show","title":"<code>show: Optional[str]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[str]</code> <p>Show slug from CRIDs path.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start","title":"<code>start: Optional[datetime]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[datetime]</code> <p>Start time form CRIDs media fragment.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>Version from CRIDs path.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__init__","title":"<code>__init__(uri=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>uri</code> <code>Optional[str]</code> <p>CRID URL to base the new CRID off of.</p> <code>None</code> Source code in <code>cridlib/lib.py</code> <pre><code>def __init__(self, uri: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Parameters:\n        uri: CRID URL to base the new CRID off of.\n    \"\"\"\n    self._show: Optional[str] = None\n    self._start: Optional[datetime] = None\n\n    self._uri = urisplit(uri)\n    if self.scheme != \"crid\":\n        raise CRIDSchemeMismatchError(self.scheme, uri)\n    if self.authority != \"rabe.ch\":\n        raise CRIDSchemeAuthorityMismatchError(self.authority, uri)\n    # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\n    if self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\n        raise CRIDUnsupportedVersionError(self.path, uri)\n    self._version = self.path.parent.stem or self.path.stem\n    # only store show if we have one\n    if self.path.stem != \"v1\":\n        self._show = self.path.relative_to(self.path.parent).stem\n    # fragments are optional, but if provided we want them to contain t=code\n    if self.fragment:\n        try:\n            self._start = datetime.strptime(\n                parse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n                \"%Y%m%dT%H%M%S.%fZ\",\n            )\n        except KeyError as ex:\n            raise CRIDMissingMediaFragmentError(self.fragment, uri) from ex\n        except ValueError as ex:  # pragma: no cover\n            raise CRIDMalformedMediaFragmentError(self.fragment, uri) from ex\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>CRID URL  rendered as string.</p> Source code in <code>cridlib/lib.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns:\n        CRID URL  rendered as string.\n    \"\"\"\n    return uricompose(*self._uri)\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDError","title":"<code>CRIDError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Represent all cridlib errors.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDError(Exception):\n    \"\"\"Represent all cridlib errors.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMalformedMediaFragmentError","title":"<code>CRIDMalformedMediaFragmentError</code>","text":"<p>             Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMalformedMediaFragmentError(CRIDError):\n    \"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMissingMediaFragmentError","title":"<code>CRIDMissingMediaFragmentError</code>","text":"<p>             Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMissingMediaFragmentError(CRIDError):\n    \"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeAuthorityMismatchError","title":"<code>CRIDSchemeAuthorityMismatchError</code>","text":"<p>             Bases: <code>CRIDError</code></p> <p>Hostname part of URI does not match 'rabe.ch'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeAuthorityMismatchError(CRIDError):\n    \"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeMismatchError","title":"<code>CRIDSchemeMismatchError</code>","text":"<p>             Bases: <code>CRIDError</code></p> <p>Scheme in URI does not match 'crid'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeMismatchError(CRIDError):\n    \"\"\"Scheme in URI does not match 'crid'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDUnsupportedVersionError","title":"<code>CRIDUnsupportedVersionError</code>","text":"<p>             Bases: <code>CRIDError</code></p> <p>Unsupported version in path of URI.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDUnsupportedVersionError(CRIDError):\n    \"\"\"Unsupported version in path of URI.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.canonicalize_show","title":"<code>canonicalize_show(show)</code>","text":"<p>Get the slug for a show.</p> <p>Uses python-slugify.</p> <p>Parameters:</p> Name Type Description Default <code>show</code> <code>str</code> <p>Name of show with non-ascii chars.</p> required <p>Returns:     slugified show name.</p> Source code in <code>cridlib/lib.py</code> <pre><code>def canonicalize_show(show: str) -&gt; str:\n    \"\"\"Get the slug for a show.\n\n    Uses [python-slugify](https://github.com/un33k/python-slugify).\n\n    Parameters:\n        show: Name of show with non-ascii chars.\n    Returns:\n        slugified show name.\n    \"\"\"\n    return slugify(show)\n</code></pre>"},{"location":"reference/cridlib/parse/","title":"parse","text":""},{"location":"reference/cridlib/parse/#cridlib.parse.parse","title":"<code>parse(value)</code>","text":"<p>Get CRID dataclass from CRID.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>CRID URL as a string.</p> required <p>Returns:     CRID: The parsed CRID.</p> Source code in <code>cridlib/parse.py</code> <pre><code>def parse(value: str) -&gt; CRID:\n    \"\"\"Get CRID dataclass from CRID.\n\n    Parameters:\n        value: CRID URL as a string.\n    Returns:\n        CRID: The parsed CRID.\n    \"\"\"\n    return CRID(value)\n</code></pre>"},{"location":"reference/cridlib/util/","title":"util","text":""},{"location":"reference/cridlib/util/#cridlib.util.get_session","title":"<code>get_session(retries=5, backoff_factor=0.1)</code>","text":"<p>Get a requests session with retry/backoff.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>How often to retry.</p> <code>5</code> <code>backoff_factor</code> <code>float</code> <p>A backoff factor to apply between attempts after the second try (most errors are resolved immediately by a second try without a delay). urllib3 will sleep for::     {backoff factor} * (2 ** ({number of total retries} - 1)) seconds. If the backoff_factor is 0.1, then :func:<code>Retry.sleep</code> will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer than <code>backoff_max</code>. By default, backoff is set to 0.1.</p> <code>0.1</code> Source code in <code>cridlib/util.py</code> <pre><code>def get_session(\n    retries: int = 5,\n    backoff_factor: float = 0.1,\n) -&gt; Session:\n    \"\"\"Get a requests session with retry/backoff.\n\n    Parameters:\n        retries: How often to retry.\n        backoff_factor: A backoff factor to apply between attempts after the\n            second try (most errors are resolved immediately by a second try\n            without a delay). urllib3 will sleep for::\n                {backoff factor} * (2 ** ({number of total retries} - 1))\n            seconds. If the backoff_factor is 0.1, then :func:`Retry.sleep`\n            will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will\n            never be longer than `backoff_max`.\n            By default, backoff is set to 0.1.\n    \"\"\"\n    session = Session()\n    session.mount(\n        \"https://\",\n        HTTPAdapter(\n            max_retries=Retry(\n                total=retries,\n                backoff_factor=backoff_factor,\n            )\n        ),\n    )\n    return session\n</code></pre>"},{"location":"reference/cridlib/strategy/","title":"strategy","text":"<p>Different strategies for getting CRIDs from different sources.</p> <ul> <li><code>cridlib.strategy.past</code></li> <li><code>cridlib.strategy.present</code></li> <li><code>cridlib.strategy.future</code></li> </ul>"},{"location":"reference/cridlib/strategy/future/","title":"future","text":""},{"location":"reference/cridlib/strategy/future/#cridlib.strategy.future.get_show","title":"<code>get_show(future)</code>","text":"<p>Return the slug for a show from LibreTime if it is in the next 7 days.</p> <p>Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023.</p> <p>Parameters:</p> Name Type Description Default <code>future</code> <code>datetime</code> <p>Date to get the show name for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Name of the show scheduled for <code>future</code>.</p> Source code in <code>cridlib/strategy/future.py</code> <pre><code>def get_show(future: datetime) -&gt; str:  # pragma: no cover\n    \"\"\"Return the slug for a show from LibreTime if it is in the next 7 days.\n\n    Only returns a show for the next seven days because everything futher than\n    that is considered unreliable as of early 2023.\n\n    Parameters:\n        future: Date to get the show name for.\n\n    Returns:\n        Name of the show scheduled for `future`.\n    \"\"\"\n\n    _resp = get_session().get(\n        __LIBRETIME_INFOV2_URL,\n        params={\n            \"days\": 7,\n            \"shows\": 7000,\n        },\n        timeout=10,\n    )\n\n    _json = _resp.json()\n    _tz = _json.get(\"station\").get(\"timezone\")\n    _next = _json.get(\"shows\").get(\"next\")\n    for _show in _next:\n        _start = datetime.fromisoformat(_show.get(\"starts\")).replace(\n            tzinfo=timezone.utc\n        )\n        _end = datetime.fromisoformat(_show.get(\"ends\")).replace(tzinfo=timezone.utc)\n        if _start &lt;= future &lt;= _end:\n            _path = PurePath(urisplit(_show.get(\"url\")).path)\n            return _path.stem\n\n    return \"\"\n</code></pre>"},{"location":"reference/cridlib/strategy/now/","title":"now","text":""},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show","title":"<code>get_show()</code>","text":"<p>Return the currently running show.</p> <p>Calls the the nowplaying songticker's API.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the currently running show.</p> Source code in <code>cridlib/strategy/now.py</code> <pre><code>def get_show() -&gt; str:\n    \"\"\"Return the currently running show.\n\n    Calls the the [nowplaying](https://github.com/radiorabe/nowplaying)\n    songticker's API.\n\n    Returns:\n        Name of the currently running show.\n    \"\"\"\n\n    _resp = get_session().get(__SONGTICKER_URL, timeout=10)\n    _tree = ET.fromstring(_resp.text)\n    _path = PurePath(urisplit(_tree[3][1].text).path)\n    return _path.stem\n</code></pre>"},{"location":"reference/cridlib/strategy/past/","title":"past","text":""},{"location":"reference/cridlib/strategy/past/#cridlib.strategy.past.get_show","title":"<code>get_show(past)</code>","text":"<p>Return a show from the past.</p> <p>Asks the the raar archive for the info.</p> <p>Parameters:</p> Name Type Description Default <code>past</code> <code>datetime</code> <p>Date to get the show name for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Show name from the archive for <code>past</code>.</p> Source code in <code>cridlib/strategy/past.py</code> <pre><code>def get_show(past: datetime) -&gt; str:\n    \"\"\"Return a show from the past.\n\n    Asks the the [raar](https://github.com/radiorabe/raar) archive for the info.\n\n    Parameters:\n        past: Date to get the show name for.\n\n    Returns:\n        Show name from the archive for `past`.\n    \"\"\"\n\n    _url = f\"{__ARCHIV_BROADCASTS_URL}{past.year}/{past.month:02d}/{past.day:02d}/{past.hour:02d}{past.minute:02d}{past.second:02d}\"  # noqa: E501\n    _resp = get_session().get(_url, timeout=10)\n    _json = _resp.json()\n    _data = _json.get(\"data\")\n    _label = str(_data[0].get(\"attributes\").get(\"label\")) if len(_data) == 1 else \"\"\n\n    return _label.lower().replace(\" \", \"-\")\n</code></pre>"}]}