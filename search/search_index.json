{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RaBe cridlib for Python","text":"<p>Generate RaBe CRIDs based on several data sources:</p> <ul> <li>Songticker for current CRID</li> <li><code>archiv.rabe.ch</code> for past CRIDs</li> <li>LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>poetry add rabe-cridlib\n\n# or on old setup style projects\npip -m install rabe-cridlib\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>&gt;&gt;&gt; import cridlib\n&gt;&gt;&gt;\n&gt;&gt;&gt; # parse an existing crid\n&gt;&gt;&gt; crid = cridlib.parse(\"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\")\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}, start: {crid.start}\")\nversion: v1, show: klangbecken, start: 1993-03-01 13:12:00\n&gt;&gt;&gt; # get crid for current show\n&gt;&gt;&gt; crid = cridlib.get()\n&gt;&gt;&gt; print(f\"version: {crid.version}, show: {crid.show}\")  # doctest:+ELLIPSIS\nversion: v1, show: ...\n</code></pre>"},{"location":"#development","title":"Development","text":"<pre><code># setup a dev env\npython -mvenv env\n. env/bin/activate\n\n# install a modern poetry version\npython -mpip install poetry&gt;=1.2.0\n\n# install deps and dev version\npoetry install\n\n# make changes, run tests\npytest\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action <code>semantic-release.yaml</code> in radiorabe/actions that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi.</p>"},{"location":"#license","title":"License","text":"<p>This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2022 Radio Bern RaBe</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cridlib<ul> <li>get</li> <li>lib</li> <li>parse</li> <li>strategy<ul> <li>future</li> <li>now</li> <li>past</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cridlib/","title":"cridlib","text":"<p>Generate RaBe Content Reference Idenitifier Spcification (CRID) Identifiers.</p>"},{"location":"reference/cridlib/#cridlib--gettimestampnone-fragment","title":"<code>get(timestamp=None, fragment='')</code>","text":"<p>Get a RaBe CRID.</p> <p>If you need to get the CRID for a specific point in RaBe time using a human-readable timezone:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from pytz import timezone\n&gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n&gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\nversion: v1, start: ...\n</code></pre>"},{"location":"reference/cridlib/#cridlib--parsevalue","title":"<code>parse(value)</code>","text":"<p>Get CRID dataclass from CRID.</p>"},{"location":"reference/cridlib/get/","title":"get","text":"<p>Main \"get\" interface for RaBe CRID's.</p>"},{"location":"reference/cridlib/get/#cridlib.get.get","title":"<code>get(timestamp=None, fragment='')</code>","text":"<p>Get a RaBe CRID.</p> <p>If you need to get the CRID for a specific point in RaBe time using a human-readable timezone:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from pytz import timezone\n&gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n&gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\nversion: v1, start: ...\n</code></pre> Source code in <code>cridlib/get.py</code> <pre><code>def get(timestamp=None, fragment=\"\") -&gt; CRID:\n\"\"\"Get a RaBe CRID.\n    If you need to get the CRID for a specific point in RaBe time using a human-readable timezone:\n    ```python\n    &gt;&gt;&gt; from datetime import datetime\n    &gt;&gt;&gt; from pytz import timezone\n    &gt;&gt;&gt; crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich')))\n    &gt;&gt;&gt; print(f\"version: {crid.version}, start: {crid.start}\")\n    version: v1, start: ...\n    ```\n    \"\"\"\n_now = datetime.now(timezone.utc)\n_ts = timestamp or _now\n_show = \"\"\nif _ts == _now:\n_show = now.get_show()\nelif _ts &lt; _now:\n_show = past.get_show(past=_ts)\nelif _ts &gt; _now:  # pragma: no cover\n_show = future.get_show(future=_ts)\n_tscode = f\"t=clock={_ts.strftime('%Y%m%dT%H%M%S.%f')[:-4]}Z\"\n_fragment = f\"{_tscode}{'&amp;' + fragment if fragment else ''}\"\nreturn CRID(f\"crid://rabe.ch/v1{'/' + _show if _show else ''}#{_fragment}\")\n</code></pre>"},{"location":"reference/cridlib/lib/","title":"lib","text":"<p>Low-level cridlib implemenetation bits.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID","title":"<code>CRID</code>","text":"<p>Represent CRIDs using uri.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRID:\n\"\"\"Represent CRIDs using uri.\"\"\"\ndef __init__(self, _uri=None) -&gt; None:\nself._show: Optional[str] = None\nself._start: Optional[datetime] = None\nself._uri = urisplit(_uri)\nif self.scheme != \"crid\":\nraise CRIDSchemeMismatchError(self.scheme)\nif self.authority != \"rabe.ch\":\nraise CRIDSchemeAuthorityMismatchError(self.authority)\n# parent.stem contains version in /v1/foo paths, stem in generic root /v1 path\nif self.path.parent.stem != \"v1\" and self.path.stem != \"v1\":\nraise CRIDUnsupportedVersionError(self.path)\nself._version = self.path.parent.stem or self.path.stem\n# only store show if we have one\nif self.path.stem != \"v1\":\nself._show = self.path.relative_to(self.path.parent).stem\n# fragments are optional, but if provided we want them to contain t=code\nif self.fragment:\ntry:\nself._start = datetime.strptime(\nparse_qs(parse_qs(self.fragment)[\"t\"][0])[\"clock\"][0],\n\"%Y%m%dT%H%M%S.%fZ\",\n)\nexcept KeyError as ex:\nraise CRIDMissingMediaFragmentError(self.fragment) from ex\nexcept ValueError as ex:  # pragma: no cover\nraise CRIDMalformedMediaFragmentError(self.fragment) from ex\ndef __str__(self) -&gt; str:\nreturn uricompose(*self._uri)\ndef __repr__(self) -&gt; str:\n\"\"\"Pretty print CRID.\n        ```python\n        &gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n        &lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n        ```\n        \"\"\"\n_fqcn = f\"{self.__class__.__module__}.{self.__class__.__qualname__}\"\nreturn f\"&lt;class '{_fqcn}' for '{str(self)}'&gt;\"\n@property\ndef scheme(self) -&gt; str:\n\"\"\"Get RaBe CRID scheme.\"\"\"\nreturn self._uri.scheme\n@property\ndef authority(self) -&gt; str:\n\"\"\"Get RaBe CRID authority.\"\"\"\nreturn self._uri.authority\n@property\ndef path(self) -&gt; CRIDPath:\n\"\"\"Get RaBe CRID path.\"\"\"\nreturn CRIDPath(self._uri.path)\n@property\ndef fragment(self) -&gt; str:\n\"\"\"Get RaBe CRID fragment.\"\"\"\nreturn self._uri.fragment\n@property\ndef version(self) -&gt; str:\n\"\"\"Get RaBe CRID version.\"\"\"\nreturn self._version\n@property\ndef show(self) -&gt; Optional[str]:\n\"\"\"Get RaBe CRID show.\"\"\"\nreturn self._show\n@property\ndef start(self) -&gt; Optional[datetime]:\n\"\"\"Get RaBe CRID start time.\"\"\"\nreturn self._start\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority","title":"<code>authority: str</code>  <code>property</code>","text":"<p>Get RaBe CRID authority.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment","title":"<code>fragment: str</code>  <code>property</code>","text":"<p>Get RaBe CRID fragment.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path","title":"<code>path: CRIDPath</code>  <code>property</code>","text":"<p>Get RaBe CRID path.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme","title":"<code>scheme: str</code>  <code>property</code>","text":"<p>Get RaBe CRID scheme.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show","title":"<code>show: Optional[str]</code>  <code>property</code>","text":"<p>Get RaBe CRID show.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start","title":"<code>start: Optional[datetime]</code>  <code>property</code>","text":"<p>Get RaBe CRID start time.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>Get RaBe CRID version.</p>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__repr__","title":"<code>__repr__()</code>","text":"<p>Pretty print CRID.</p> <pre><code>&gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n&lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n</code></pre> Source code in <code>cridlib/lib.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Pretty print CRID.\n    ```python\n    &gt;&gt;&gt; CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")\n    &lt;class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'&gt;\n    ```\n    \"\"\"\n_fqcn = f\"{self.__class__.__module__}.{self.__class__.__qualname__}\"\nreturn f\"&lt;class '{_fqcn}' for '{str(self)}'&gt;\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDError","title":"<code>CRIDError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Represent all cridlib errors.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDError(Exception):\n\"\"\"Represent all cridlib errors.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMalformedMediaFragmentError","title":"<code>CRIDMalformedMediaFragmentError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMalformedMediaFragmentError(CRIDError):\n\"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMissingMediaFragmentError","title":"<code>CRIDMissingMediaFragmentError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Missing media-fragment with clock code.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDMissingMediaFragmentError(CRIDError):\n\"\"\"Missing media-fragment with clock code.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeAuthorityMismatchError","title":"<code>CRIDSchemeAuthorityMismatchError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Hostname part of URI does not match 'rabe.ch'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeAuthorityMismatchError(CRIDError):\n\"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeMismatchError","title":"<code>CRIDSchemeMismatchError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Scheme in URI does not match 'crid'.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDSchemeMismatchError(CRIDError):\n\"\"\"Scheme in URI does not match 'crid'.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDUnsupportedVersionError","title":"<code>CRIDUnsupportedVersionError</code>","text":"<p>         Bases: <code>CRIDError</code></p> <p>Unsupported version in path of URI.</p> Source code in <code>cridlib/lib.py</code> <pre><code>class CRIDUnsupportedVersionError(CRIDError):\n\"\"\"Unsupported version in path of URI.\"\"\"\n</code></pre>"},{"location":"reference/cridlib/parse/","title":"parse","text":"<p>Parse RaBe CRID's.</p>"},{"location":"reference/cridlib/parse/#cridlib.parse.parse","title":"<code>parse(value)</code>","text":"<p>Get CRID dataclass from CRID.</p> Source code in <code>cridlib/parse.py</code> <pre><code>def parse(value: str) -&gt; CRID:\n\"\"\"Get CRID dataclass from CRID.\"\"\"\nreturn CRID(value)\n</code></pre>"},{"location":"reference/cridlib/strategy/","title":"strategy","text":""},{"location":"reference/cridlib/strategy/future/","title":"future","text":"<p>The future strategy implements getting data from LibreTime.</p>"},{"location":"reference/cridlib/strategy/future/#cridlib.strategy.future.get_show","title":"<code>get_show(future)</code>","text":"<p>Return the slug for a show from LibreTime if it is in the next 7 days.</p> Source code in <code>cridlib/strategy/future.py</code> <pre><code>def get_show(future: datetime) -&gt; str:  # pragma: no cover\n\"\"\"Return the slug for a show from LibreTime if it is in the next 7 days.\"\"\"\n_resp = requests.get(\n__LIBRETIME_INFOV2_URL,\nparams={\n\"days\": 7,\n\"shows\": 7000,\n},\ntimeout=10,\n)\n_json = _resp.json()\n_tz = _json.get(\"station\").get(\"timezone\")\n_next = _json.get(\"shows\").get(\"next\")\nfor _show in _next:\n_start = datetime.fromisoformat(_show.get(\"starts\")).replace(\ntzinfo=timezone.utc\n)\n_end = datetime.fromisoformat(_show.get(\"ends\")).replace(tzinfo=timezone.utc)\nif _start &lt;= future &lt;= _end:\n_path = PurePath(urisplit(_show.get(\"url\")).path)\nreturn _path.stem\nreturn \"\"\n</code></pre>"},{"location":"reference/cridlib/strategy/now/","title":"now","text":"<p>The now strategy implements getting data from Songticker.</p>"},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show","title":"<code>get_show()</code>","text":"<p>Return the currently running shows slug from nowplaying.</p> Source code in <code>cridlib/strategy/now.py</code> <pre><code>def get_show() -&gt; str:\n\"\"\"Return the currently running shows slug from nowplaying.\"\"\"\n_resp = requests.get(__SONGTICKER_URL, timeout=10)\n_tree = ET.fromstring(_resp.text)\n_path = PurePath(urisplit(_tree[3][1].text).path)\nreturn _path.stem\n</code></pre>"},{"location":"reference/cridlib/strategy/past/","title":"past","text":"<p>The past strategy implements getting data from archiv.rabe.ch.</p>"},{"location":"reference/cridlib/strategy/past/#cridlib.strategy.past.get_show","title":"<code>get_show(past)</code>","text":"<p>Return the a show slug from a past show.</p> Source code in <code>cridlib/strategy/past.py</code> <pre><code>def get_show(past: datetime) -&gt; str:\n\"\"\"Return the a show slug from a past show.\"\"\"\n_url = f\"{__ARCHIV_BROADCASTS_URL}{past.year}/{past.month:02d}/{past.day:02d}/{past.hour:02d}{past.minute:02d}{past.second:02d}\"  # pylint: disable=line-too-long\n_resp = requests.get(_url, timeout=10)\n_json = _resp.json()\n_data = _json.get(\"data\")\n_label = str(_data[0].get(\"attributes\").get(\"label\"))\nreturn _label.lower().replace(\" \", \"-\")\n</code></pre>"}]}