{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RaBe cridlib for Python Generate RaBe CRIDs based on several data sources: Songticker for current CRID archiv.rabe.ch for past CRIDs LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe) Installation poetry add rabe-cridlib # or on old setup style projects pip -m install rabe-cridlib Usage >>> import cridlib >>> >>> # parse an existing crid >>> crid = cridlib . parse ( \"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\" ) >>> print ( f \"version: { crid . version } , show: { crid . show } , start: { crid . start } \" ) version : v1 , show : klangbecken , start : 1993 - 03 - 01 13 : 12 : 00 >>> # get crid for current show >>> crid = cridlib . get () >>> print ( f \"version: { crid . version } , show: { crid . show } \" ) # doctest:+ELLIPSIS version : v1 , show : ... Development # setup a dev env python -mvenv env . env/bin/activate # install a modern poetry version python -mpip install poetry> = 1 .2.0 # install deps and dev version poetry install # make changes, run tests pytest Release Management The CI/CD setup uses semantic commit messages following the conventional commits standard . There is a GitHub Action semantic-release.yaml in radiorabe/actions that uses go-semantic-commit to create new releases. The commit message should be structured as follows: <type>[optional scope]: <description> [optional body] [optional footer(s)] The commit contains the following structural elements, to communicate intent to the consumers of your library: fix: a commit of the type fix patches gets released with a PATCH version bump feat: a commit of the type feat gets released as a MINOR version bump BREAKING CHANGE: a commit that has a footer BREAKING CHANGE: gets released as a MAJOR version bump types other than fix: and feat: are allowed and don't trigger a release If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR. Once a commit has landed on the main branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi. License This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License. Copyright Copyright (c) 2022 Radio Bern RaBe","title":"README"},{"location":"#rabe-cridlib-for-python","text":"Generate RaBe CRIDs based on several data sources: Songticker for current CRID archiv.rabe.ch for past CRIDs LibreTime for future CRIDs (currently only data for the next 7 days and only available internally at RaBe)","title":"RaBe cridlib for Python"},{"location":"#installation","text":"poetry add rabe-cridlib # or on old setup style projects pip -m install rabe-cridlib","title":"Installation"},{"location":"#usage","text":">>> import cridlib >>> >>> # parse an existing crid >>> crid = cridlib . parse ( \"crid://rabe.ch/v1/klangbecken#t=clock=19930301T131200.00Z\" ) >>> print ( f \"version: { crid . version } , show: { crid . show } , start: { crid . start } \" ) version : v1 , show : klangbecken , start : 1993 - 03 - 01 13 : 12 : 00 >>> # get crid for current show >>> crid = cridlib . get () >>> print ( f \"version: { crid . version } , show: { crid . show } \" ) # doctest:+ELLIPSIS version : v1 , show : ...","title":"Usage"},{"location":"#development","text":"# setup a dev env python -mvenv env . env/bin/activate # install a modern poetry version python -mpip install poetry> = 1 .2.0 # install deps and dev version poetry install # make changes, run tests pytest","title":"Development"},{"location":"#release-management","text":"The CI/CD setup uses semantic commit messages following the conventional commits standard . There is a GitHub Action semantic-release.yaml in radiorabe/actions that uses go-semantic-commit to create new releases. The commit message should be structured as follows: <type>[optional scope]: <description> [optional body] [optional footer(s)] The commit contains the following structural elements, to communicate intent to the consumers of your library: fix: a commit of the type fix patches gets released with a PATCH version bump feat: a commit of the type feat gets released as a MINOR version bump BREAKING CHANGE: a commit that has a footer BREAKING CHANGE: gets released as a MAJOR version bump types other than fix: and feat: are allowed and don't trigger a release If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR. Once a commit has landed on the main branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/release.yaml which uses poetry to publish the package to pypi.","title":"Release Management"},{"location":"#license","text":"This package is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.","title":"License"},{"location":"#copyright","text":"Copyright (c) 2022 Radio Bern RaBe","title":"Copyright"},{"location":"reference/SUMMARY/","text":"cridlib get lib parse strategy future now past util","title":"SUMMARY"},{"location":"reference/cridlib/","text":"Generate RaBe Content Reference Idenitifier Spcification (CRID) Identifiers. cridlib.get(timestamp=None, fragment='') cridlib.parse(value)","title":"cridlib"},{"location":"reference/cridlib/get/","text":"get ( timestamp = None , fragment = '' ) Get a RaBe CRID. Examples: You can get a CRID for a specific time. >>> from datetime import datetime >>> from pytz import timezone >>> crid = get ( datetime ( 2020 , 3 , 1 , 00 , 00 , tzinfo = timezone ( 'Europe/Zurich' ))) >>> print ( f \"version: { crid . version } , start: { crid . start } \" ) version : v1 , start : ... Parameters: Name Type Description Default timestamp Optional [ datetime ] Exact time you want a CRID for. If left empty, a CRID for the current time is generated. None fragment str Optional fragment to add to the end of the CRID. '' Returns: Name Type Description CRID CRID The generated CRID. Source code in cridlib/get.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def get ( timestamp : Optional [ datetime ] = None , fragment : str = \"\" ) -> CRID : \"\"\"Get a RaBe CRID. Examples: You can get a CRID for a specific time. ```python >>> from datetime import datetime >>> from pytz import timezone >>> crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich'))) >>> print(f\"version: {crid.version}, start: {crid.start}\") version: v1, start: ... ``` Parameters: timestamp: Exact time you want a CRID for. If left empty, a CRID for the current time is generated. fragment: Optional fragment to add to the end of the CRID. Returns: CRID: The generated CRID. \"\"\" _now = datetime . now ( timezone . utc ) _ts = timestamp or _now _show = \"\" if _ts == _now : _show = now . get_show () elif _ts < _now : _show = past . get_show ( past = _ts ) elif _ts > _now : # pragma: no cover _show = future . get_show ( future = _ts ) if _show : _show = canonicalize_show ( _show ) _tscode = f \"t=clock= { _ts . strftime ( '%Y%m %d T%H%M%S. %f ' )[: - 4 ] } Z\" _fragment = f \" { _tscode }{ '&' + fragment if fragment else '' } \" return CRID ( f \"crid://rabe.ch/v1 { '/' + _show if _show else '' } # { _fragment } \" )","title":"get"},{"location":"reference/cridlib/get/#cridlib.get.get","text":"Get a RaBe CRID. Examples: You can get a CRID for a specific time. >>> from datetime import datetime >>> from pytz import timezone >>> crid = get ( datetime ( 2020 , 3 , 1 , 00 , 00 , tzinfo = timezone ( 'Europe/Zurich' ))) >>> print ( f \"version: { crid . version } , start: { crid . start } \" ) version : v1 , start : ... Parameters: Name Type Description Default timestamp Optional [ datetime ] Exact time you want a CRID for. If left empty, a CRID for the current time is generated. None fragment str Optional fragment to add to the end of the CRID. '' Returns: Name Type Description CRID CRID The generated CRID. Source code in cridlib/get.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def get ( timestamp : Optional [ datetime ] = None , fragment : str = \"\" ) -> CRID : \"\"\"Get a RaBe CRID. Examples: You can get a CRID for a specific time. ```python >>> from datetime import datetime >>> from pytz import timezone >>> crid = get(datetime(2020, 3, 1, 00, 00, tzinfo=timezone('Europe/Zurich'))) >>> print(f\"version: {crid.version}, start: {crid.start}\") version: v1, start: ... ``` Parameters: timestamp: Exact time you want a CRID for. If left empty, a CRID for the current time is generated. fragment: Optional fragment to add to the end of the CRID. Returns: CRID: The generated CRID. \"\"\" _now = datetime . now ( timezone . utc ) _ts = timestamp or _now _show = \"\" if _ts == _now : _show = now . get_show () elif _ts < _now : _show = past . get_show ( past = _ts ) elif _ts > _now : # pragma: no cover _show = future . get_show ( future = _ts ) if _show : _show = canonicalize_show ( _show ) _tscode = f \"t=clock= { _ts . strftime ( '%Y%m %d T%H%M%S. %f ' )[: - 4 ] } Z\" _fragment = f \" { _tscode }{ '&' + fragment if fragment else '' } \" return CRID ( f \"crid://rabe.ch/v1 { '/' + _show if _show else '' } # { _fragment } \" )","title":"get()"},{"location":"reference/cridlib/lib/","text":"CRID Represent CRIDs and can parse, validate and render them. Examples: Generate a CRID from an URL and render it's repr: >>> CRID ( \"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\" ) < class ' cridlib . lib . CRID ' for ' crid : // rabe . ch / v1 / test #t=clock=19930301T131200.00Z'> Generate a CRID and render it as str: >>> str ( CRID ( \"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\" )) 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z' Source code in cridlib/lib.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class CRID : \"\"\"Represent CRIDs and can parse, validate and render them. Examples: Generate a CRID from an URL and render it's repr: ```python >>> CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\") <class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'> ``` Generate a CRID and render it as str: ```python >>> str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")) 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z' ``` \"\"\" def __init__ ( self , uri : Optional [ str ] = None ) -> None : \"\"\" Parameters: uri: CRID URL to base the new CRID off of. \"\"\" self . _show : Optional [ str ] = None self . _start : Optional [ datetime ] = None self . _uri = urisplit ( uri ) if self . scheme != \"crid\" : raise CRIDSchemeMismatchError ( self . scheme , uri ) if self . authority != \"rabe.ch\" : raise CRIDSchemeAuthorityMismatchError ( self . authority , uri ) # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path if self . path . parent . stem != \"v1\" and self . path . stem != \"v1\" : raise CRIDUnsupportedVersionError ( self . path , uri ) self . _version = self . path . parent . stem or self . path . stem # only store show if we have one if self . path . stem != \"v1\" : self . _show = self . path . relative_to ( self . path . parent ) . stem # fragments are optional, but if provided we want them to contain t=code if self . fragment : try : self . _start = datetime . strptime ( parse_qs ( parse_qs ( self . fragment )[ \"t\" ][ 0 ])[ \"clock\" ][ 0 ], \"%Y%m %d T%H%M%S. %f Z\" , ) except KeyError as ex : raise CRIDMissingMediaFragmentError ( self . fragment , uri ) from ex except ValueError as ex : # pragma: no cover raise CRIDMalformedMediaFragmentError ( self . fragment , uri ) from ex def __str__ ( self ) -> str : \"\"\" Returns: CRID URL rendered as string. \"\"\" return uricompose ( * self . _uri ) def __repr__ ( self ) -> str : _fqcn = f \" { self . __class__ . __module__ } . { self . __class__ . __qualname__ } \" return f \"<class ' { _fqcn } ' for ' { str ( self ) } '>\" @property def scheme ( self ) -> str : \"\"\" Returns: Scheme part of the CRID. \"\"\" return self . _uri . scheme @property def authority ( self ) -> str : \"\"\" Returns: Authority part (aka hostname) of CRID. \"\"\" return self . _uri . authority @property def path ( self ) -> CRIDPath : \"\"\" Returns: Path part of CRID. \"\"\" return CRIDPath ( self . _uri . path ) @property def fragment ( self ) -> str : \"\"\" Returns: Framgment part of CRID. \"\"\" return self . _uri . fragment @property def version ( self ) -> str : \"\"\" Returns: Version from CRIDs path. \"\"\" return self . _version @property def show ( self ) -> Optional [ str ]: \"\"\" Returns: Show slug from CRIDs path. \"\"\" return self . _show @property def start ( self ) -> Optional [ datetime ]: \"\"\" Returns: Start time form CRIDs media fragment. \"\"\" return self . _start authority : str property Returns: Type Description str Authority part (aka hostname) of CRID. fragment : str property Returns: Type Description str Framgment part of CRID. path : CRIDPath property Returns: Type Description CRIDPath Path part of CRID. scheme : str property Returns: Type Description str Scheme part of the CRID. show : Optional [ str ] property Returns: Type Description Optional [ str ] Show slug from CRIDs path. start : Optional [ datetime ] property Returns: Type Description Optional [ datetime ] Start time form CRIDs media fragment. version : str property Returns: Type Description str Version from CRIDs path. __init__ ( uri = None ) Parameters: Name Type Description Default uri Optional [ str ] CRID URL to base the new CRID off of. None Source code in cridlib/lib.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self , uri : Optional [ str ] = None ) -> None : \"\"\" Parameters: uri: CRID URL to base the new CRID off of. \"\"\" self . _show : Optional [ str ] = None self . _start : Optional [ datetime ] = None self . _uri = urisplit ( uri ) if self . scheme != \"crid\" : raise CRIDSchemeMismatchError ( self . scheme , uri ) if self . authority != \"rabe.ch\" : raise CRIDSchemeAuthorityMismatchError ( self . authority , uri ) # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path if self . path . parent . stem != \"v1\" and self . path . stem != \"v1\" : raise CRIDUnsupportedVersionError ( self . path , uri ) self . _version = self . path . parent . stem or self . path . stem # only store show if we have one if self . path . stem != \"v1\" : self . _show = self . path . relative_to ( self . path . parent ) . stem # fragments are optional, but if provided we want them to contain t=code if self . fragment : try : self . _start = datetime . strptime ( parse_qs ( parse_qs ( self . fragment )[ \"t\" ][ 0 ])[ \"clock\" ][ 0 ], \"%Y%m %d T%H%M%S. %f Z\" , ) except KeyError as ex : raise CRIDMissingMediaFragmentError ( self . fragment , uri ) from ex except ValueError as ex : # pragma: no cover raise CRIDMalformedMediaFragmentError ( self . fragment , uri ) from ex __str__ () Returns: Type Description str CRID URL rendered as string. Source code in cridlib/lib.py 99 100 101 102 103 104 def __str__ ( self ) -> str : \"\"\" Returns: CRID URL rendered as string. \"\"\" return uricompose ( * self . _uri ) CRIDError Bases: Exception Represent all cridlib errors. Source code in cridlib/lib.py 21 22 class CRIDError ( Exception ): \"\"\"Represent all cridlib errors.\"\"\" CRIDMalformedMediaFragmentError Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 41 42 class CRIDMalformedMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\" CRIDMissingMediaFragmentError Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 37 38 class CRIDMissingMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\" CRIDSchemeAuthorityMismatchError Bases: CRIDError Hostname part of URI does not match 'rabe.ch'. Source code in cridlib/lib.py 29 30 class CRIDSchemeAuthorityMismatchError ( CRIDError ): \"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\" CRIDSchemeMismatchError Bases: CRIDError Scheme in URI does not match 'crid'. Source code in cridlib/lib.py 25 26 class CRIDSchemeMismatchError ( CRIDError ): \"\"\"Scheme in URI does not match 'crid'.\"\"\" CRIDUnsupportedVersionError Bases: CRIDError Unsupported version in path of URI. Source code in cridlib/lib.py 33 34 class CRIDUnsupportedVersionError ( CRIDError ): \"\"\"Unsupported version in path of URI.\"\"\" canonicalize_show ( show ) Get the slug for a show using python-slugify . Parameters: Name Type Description Default show str Name of show with non-ascii chars. required Returns: Type Description str slugified show name. Source code in cridlib/lib.py 10 11 12 13 14 15 16 17 18 def canonicalize_show ( show : str ) -> str : \"\"\"Get the slug for a show using [python-slugify](https://github.com/un33k/python-slugify). Parameters: show: Name of show with non-ascii chars. Returns: slugified show name. \"\"\" return slugify ( show )","title":"lib"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID","text":"Represent CRIDs and can parse, validate and render them. Examples: Generate a CRID from an URL and render it's repr: >>> CRID ( \"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\" ) < class ' cridlib . lib . CRID ' for ' crid : // rabe . ch / v1 / test #t=clock=19930301T131200.00Z'> Generate a CRID and render it as str: >>> str ( CRID ( \"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\" )) 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z' Source code in cridlib/lib.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class CRID : \"\"\"Represent CRIDs and can parse, validate and render them. Examples: Generate a CRID from an URL and render it's repr: ```python >>> CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\") <class 'cridlib.lib.CRID' for 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z'> ``` Generate a CRID and render it as str: ```python >>> str(CRID(\"crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z\")) 'crid://rabe.ch/v1/test#t=clock=19930301T131200.00Z' ``` \"\"\" def __init__ ( self , uri : Optional [ str ] = None ) -> None : \"\"\" Parameters: uri: CRID URL to base the new CRID off of. \"\"\" self . _show : Optional [ str ] = None self . _start : Optional [ datetime ] = None self . _uri = urisplit ( uri ) if self . scheme != \"crid\" : raise CRIDSchemeMismatchError ( self . scheme , uri ) if self . authority != \"rabe.ch\" : raise CRIDSchemeAuthorityMismatchError ( self . authority , uri ) # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path if self . path . parent . stem != \"v1\" and self . path . stem != \"v1\" : raise CRIDUnsupportedVersionError ( self . path , uri ) self . _version = self . path . parent . stem or self . path . stem # only store show if we have one if self . path . stem != \"v1\" : self . _show = self . path . relative_to ( self . path . parent ) . stem # fragments are optional, but if provided we want them to contain t=code if self . fragment : try : self . _start = datetime . strptime ( parse_qs ( parse_qs ( self . fragment )[ \"t\" ][ 0 ])[ \"clock\" ][ 0 ], \"%Y%m %d T%H%M%S. %f Z\" , ) except KeyError as ex : raise CRIDMissingMediaFragmentError ( self . fragment , uri ) from ex except ValueError as ex : # pragma: no cover raise CRIDMalformedMediaFragmentError ( self . fragment , uri ) from ex def __str__ ( self ) -> str : \"\"\" Returns: CRID URL rendered as string. \"\"\" return uricompose ( * self . _uri ) def __repr__ ( self ) -> str : _fqcn = f \" { self . __class__ . __module__ } . { self . __class__ . __qualname__ } \" return f \"<class ' { _fqcn } ' for ' { str ( self ) } '>\" @property def scheme ( self ) -> str : \"\"\" Returns: Scheme part of the CRID. \"\"\" return self . _uri . scheme @property def authority ( self ) -> str : \"\"\" Returns: Authority part (aka hostname) of CRID. \"\"\" return self . _uri . authority @property def path ( self ) -> CRIDPath : \"\"\" Returns: Path part of CRID. \"\"\" return CRIDPath ( self . _uri . path ) @property def fragment ( self ) -> str : \"\"\" Returns: Framgment part of CRID. \"\"\" return self . _uri . fragment @property def version ( self ) -> str : \"\"\" Returns: Version from CRIDs path. \"\"\" return self . _version @property def show ( self ) -> Optional [ str ]: \"\"\" Returns: Show slug from CRIDs path. \"\"\" return self . _show @property def start ( self ) -> Optional [ datetime ]: \"\"\" Returns: Start time form CRIDs media fragment. \"\"\" return self . _start","title":"CRID"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.authority","text":"Returns: Type Description str Authority part (aka hostname) of CRID.","title":"authority"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.fragment","text":"Returns: Type Description str Framgment part of CRID.","title":"fragment"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.path","text":"Returns: Type Description CRIDPath Path part of CRID.","title":"path"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.scheme","text":"Returns: Type Description str Scheme part of the CRID.","title":"scheme"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.show","text":"Returns: Type Description Optional [ str ] Show slug from CRIDs path.","title":"show"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.start","text":"Returns: Type Description Optional [ datetime ] Start time form CRIDs media fragment.","title":"start"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.version","text":"Returns: Type Description str Version from CRIDs path.","title":"version"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__init__","text":"Parameters: Name Type Description Default uri Optional [ str ] CRID URL to base the new CRID off of. None Source code in cridlib/lib.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self , uri : Optional [ str ] = None ) -> None : \"\"\" Parameters: uri: CRID URL to base the new CRID off of. \"\"\" self . _show : Optional [ str ] = None self . _start : Optional [ datetime ] = None self . _uri = urisplit ( uri ) if self . scheme != \"crid\" : raise CRIDSchemeMismatchError ( self . scheme , uri ) if self . authority != \"rabe.ch\" : raise CRIDSchemeAuthorityMismatchError ( self . authority , uri ) # parent.stem contains version in /v1/foo paths, stem in generic root /v1 path if self . path . parent . stem != \"v1\" and self . path . stem != \"v1\" : raise CRIDUnsupportedVersionError ( self . path , uri ) self . _version = self . path . parent . stem or self . path . stem # only store show if we have one if self . path . stem != \"v1\" : self . _show = self . path . relative_to ( self . path . parent ) . stem # fragments are optional, but if provided we want them to contain t=code if self . fragment : try : self . _start = datetime . strptime ( parse_qs ( parse_qs ( self . fragment )[ \"t\" ][ 0 ])[ \"clock\" ][ 0 ], \"%Y%m %d T%H%M%S. %f Z\" , ) except KeyError as ex : raise CRIDMissingMediaFragmentError ( self . fragment , uri ) from ex except ValueError as ex : # pragma: no cover raise CRIDMalformedMediaFragmentError ( self . fragment , uri ) from ex","title":"__init__()"},{"location":"reference/cridlib/lib/#cridlib.lib.CRID.__str__","text":"Returns: Type Description str CRID URL rendered as string. Source code in cridlib/lib.py 99 100 101 102 103 104 def __str__ ( self ) -> str : \"\"\" Returns: CRID URL rendered as string. \"\"\" return uricompose ( * self . _uri )","title":"__str__()"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDError","text":"Bases: Exception Represent all cridlib errors. Source code in cridlib/lib.py 21 22 class CRIDError ( Exception ): \"\"\"Represent all cridlib errors.\"\"\"","title":"CRIDError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMalformedMediaFragmentError","text":"Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 41 42 class CRIDMalformedMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\"","title":"CRIDMalformedMediaFragmentError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDMissingMediaFragmentError","text":"Bases: CRIDError Missing media-fragment with clock code. Source code in cridlib/lib.py 37 38 class CRIDMissingMediaFragmentError ( CRIDError ): \"\"\"Missing media-fragment with clock code.\"\"\"","title":"CRIDMissingMediaFragmentError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeAuthorityMismatchError","text":"Bases: CRIDError Hostname part of URI does not match 'rabe.ch'. Source code in cridlib/lib.py 29 30 class CRIDSchemeAuthorityMismatchError ( CRIDError ): \"\"\"Hostname part of URI does not match 'rabe.ch'.\"\"\"","title":"CRIDSchemeAuthorityMismatchError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDSchemeMismatchError","text":"Bases: CRIDError Scheme in URI does not match 'crid'. Source code in cridlib/lib.py 25 26 class CRIDSchemeMismatchError ( CRIDError ): \"\"\"Scheme in URI does not match 'crid'.\"\"\"","title":"CRIDSchemeMismatchError"},{"location":"reference/cridlib/lib/#cridlib.lib.CRIDUnsupportedVersionError","text":"Bases: CRIDError Unsupported version in path of URI. Source code in cridlib/lib.py 33 34 class CRIDUnsupportedVersionError ( CRIDError ): \"\"\"Unsupported version in path of URI.\"\"\"","title":"CRIDUnsupportedVersionError"},{"location":"reference/cridlib/lib/#cridlib.lib.canonicalize_show","text":"Get the slug for a show using python-slugify . Parameters: Name Type Description Default show str Name of show with non-ascii chars. required Returns: Type Description str slugified show name. Source code in cridlib/lib.py 10 11 12 13 14 15 16 17 18 def canonicalize_show ( show : str ) -> str : \"\"\"Get the slug for a show using [python-slugify](https://github.com/un33k/python-slugify). Parameters: show: Name of show with non-ascii chars. Returns: slugified show name. \"\"\" return slugify ( show )","title":"canonicalize_show()"},{"location":"reference/cridlib/parse/","text":"parse ( value ) Get CRID dataclass from CRID. Parameters: Name Type Description Default value str CRID URL as a string. required Returns: Name Type Description CRID CRID The parsed CRID. Source code in cridlib/parse.py 4 5 6 7 8 9 10 11 12 def parse ( value : str ) -> CRID : \"\"\"Get CRID dataclass from CRID. Parameters: value: CRID URL as a string. Returns: CRID: The parsed CRID. \"\"\" return CRID ( value )","title":"parse"},{"location":"reference/cridlib/parse/#cridlib.parse.parse","text":"Get CRID dataclass from CRID. Parameters: Name Type Description Default value str CRID URL as a string. required Returns: Name Type Description CRID CRID The parsed CRID. Source code in cridlib/parse.py 4 5 6 7 8 9 10 11 12 def parse ( value : str ) -> CRID : \"\"\"Get CRID dataclass from CRID. Parameters: value: CRID URL as a string. Returns: CRID: The parsed CRID. \"\"\" return CRID ( value )","title":"parse()"},{"location":"reference/cridlib/util/","text":"get_session ( retries = 5 , backoff_factor = 0.1 ) Get a requests session with retry/backoff. Parameters: Name Type Description Default retries int How often to retry. 5 backoff_factor float A backoff factor to apply between attempts after the second try (most errors are resolved immediately by a second try without a delay). urllib3 will sleep for:: {backoff factor} * (2 ** ({number of total retries} - 1)) seconds. If the backoff_factor is 0.1, then :func: Retry.sleep will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer than backoff_max . By default, backoff is set to 0.1. 0.1 Source code in cridlib/util.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def get_session ( retries : int = 5 , backoff_factor : float = 0.1 , ) -> Session : \"\"\"Get a requests session with retry/backoff. Parameters: retries: How often to retry. backoff_factor: A backoff factor to apply between attempts after the second try (most errors are resolved immediately by a second try without a delay). urllib3 will sleep for:: {backoff factor} * (2 ** ({number of total retries} - 1)) seconds. If the backoff_factor is 0.1, then :func:`Retry.sleep` will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer than `backoff_max`. By default, backoff is set to 0.1. \"\"\" session = Session () session . mount ( \"https://\" , HTTPAdapter ( max_retries = Retry ( total = retries , backoff_factor = backoff_factor , ) ), ) return session","title":"util"},{"location":"reference/cridlib/util/#cridlib.util.get_session","text":"Get a requests session with retry/backoff. Parameters: Name Type Description Default retries int How often to retry. 5 backoff_factor float A backoff factor to apply between attempts after the second try (most errors are resolved immediately by a second try without a delay). urllib3 will sleep for:: {backoff factor} * (2 ** ({number of total retries} - 1)) seconds. If the backoff_factor is 0.1, then :func: Retry.sleep will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer than backoff_max . By default, backoff is set to 0.1. 0.1 Source code in cridlib/util.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def get_session ( retries : int = 5 , backoff_factor : float = 0.1 , ) -> Session : \"\"\"Get a requests session with retry/backoff. Parameters: retries: How often to retry. backoff_factor: A backoff factor to apply between attempts after the second try (most errors are resolved immediately by a second try without a delay). urllib3 will sleep for:: {backoff factor} * (2 ** ({number of total retries} - 1)) seconds. If the backoff_factor is 0.1, then :func:`Retry.sleep` will sleep for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer than `backoff_max`. By default, backoff is set to 0.1. \"\"\" session = Session () session . mount ( \"https://\" , HTTPAdapter ( max_retries = Retry ( total = retries , backoff_factor = backoff_factor , ) ), ) return session","title":"get_session()"},{"location":"reference/cridlib/strategy/","text":"Different strategies for getting CRIDs from different sources. cridlib.strategy.past cridlib.strategy.present cridlib.strategy.future","title":"strategy"},{"location":"reference/cridlib/strategy/future/","text":"get_show ( future ) Return the slug for a show from LibreTime if it is in the next 7 days. Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023. Parameters: Name Type Description Default future datetime Date to get the show name for. required Returns: Type Description str Name of the show scheduled for future . Source code in cridlib/strategy/future.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def get_show ( future : datetime ) -> str : # pragma: no cover \"\"\"Return the slug for a show from LibreTime if it is in the next 7 days. Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023. Parameters: future: Date to get the show name for. Returns: Name of the show scheduled for `future`. \"\"\" _resp = get_session () . get ( __LIBRETIME_INFOV2_URL , params = { \"days\" : 7 , \"shows\" : 7000 , }, timeout = 10 , ) _json = _resp . json () _tz = _json . get ( \"station\" ) . get ( \"timezone\" ) _next = _json . get ( \"shows\" ) . get ( \"next\" ) for _show in _next : _start = datetime . fromisoformat ( _show . get ( \"starts\" )) . replace ( tzinfo = timezone . utc ) _end = datetime . fromisoformat ( _show . get ( \"ends\" )) . replace ( tzinfo = timezone . utc ) if _start <= future <= _end : _path = PurePath ( urisplit ( _show . get ( \"url\" )) . path ) return _path . stem return \"\"","title":"future"},{"location":"reference/cridlib/strategy/future/#cridlib.strategy.future.get_show","text":"Return the slug for a show from LibreTime if it is in the next 7 days. Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023. Parameters: Name Type Description Default future datetime Date to get the show name for. required Returns: Type Description str Name of the show scheduled for future . Source code in cridlib/strategy/future.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def get_show ( future : datetime ) -> str : # pragma: no cover \"\"\"Return the slug for a show from LibreTime if it is in the next 7 days. Only returns a show for the next seven days because everything futher than that is considered unreliable as of early 2023. Parameters: future: Date to get the show name for. Returns: Name of the show scheduled for `future`. \"\"\" _resp = get_session () . get ( __LIBRETIME_INFOV2_URL , params = { \"days\" : 7 , \"shows\" : 7000 , }, timeout = 10 , ) _json = _resp . json () _tz = _json . get ( \"station\" ) . get ( \"timezone\" ) _next = _json . get ( \"shows\" ) . get ( \"next\" ) for _show in _next : _start = datetime . fromisoformat ( _show . get ( \"starts\" )) . replace ( tzinfo = timezone . utc ) _end = datetime . fromisoformat ( _show . get ( \"ends\" )) . replace ( tzinfo = timezone . utc ) if _start <= future <= _end : _path = PurePath ( urisplit ( _show . get ( \"url\" )) . path ) return _path . stem return \"\"","title":"get_show()"},{"location":"reference/cridlib/strategy/now/","text":"get_show () Return the currently running show. Calls the the nowplaying songticker's API. Returns: Type Description str Name of the currently running show. Source code in cridlib/strategy/now.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def get_show () -> str : \"\"\"Return the currently running show. Calls the the [nowplaying](https://github.com/radiorabe/nowplaying) songticker's API. Returns: Name of the currently running show. \"\"\" _resp = get_session () . get ( __SONGTICKER_URL , timeout = 10 ) _tree = ET . fromstring ( _resp . text ) _path = PurePath ( urisplit ( _tree [ 3 ][ 1 ] . text ) . path ) return _path . stem","title":"now"},{"location":"reference/cridlib/strategy/now/#cridlib.strategy.now.get_show","text":"Return the currently running show. Calls the the nowplaying songticker's API. Returns: Type Description str Name of the currently running show. Source code in cridlib/strategy/now.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def get_show () -> str : \"\"\"Return the currently running show. Calls the the [nowplaying](https://github.com/radiorabe/nowplaying) songticker's API. Returns: Name of the currently running show. \"\"\" _resp = get_session () . get ( __SONGTICKER_URL , timeout = 10 ) _tree = ET . fromstring ( _resp . text ) _path = PurePath ( urisplit ( _tree [ 3 ][ 1 ] . text ) . path ) return _path . stem","title":"get_show()"},{"location":"reference/cridlib/strategy/past/","text":"get_show ( past ) Return a show from the past. Asks the the raar archive for the info. Parameters: Name Type Description Default past datetime Date to get the show name for. required Returns: Type Description str Show name from the archive for past . Source code in cridlib/strategy/past.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def get_show ( past : datetime ) -> str : \"\"\"Return a show from the past. Asks the the [raar](https://github.com/radiorabe/raar) archive for the info. Parameters: past: Date to get the show name for. Returns: Show name from the archive for `past`. \"\"\" _url = f \" { __ARCHIV_BROADCASTS_URL }{ past . year } / { past . month : 02d } / { past . day : 02d } / { past . hour : 02d }{ past . minute : 02d }{ past . second : 02d } \" # pylint: disable=line-too-long _resp = get_session () . get ( _url , timeout = 10 ) _json = _resp . json () _data = _json . get ( \"data\" ) _label = str ( _data [ 0 ] . get ( \"attributes\" ) . get ( \"label\" )) return _label . lower () . replace ( \" \" , \"-\" )","title":"past"},{"location":"reference/cridlib/strategy/past/#cridlib.strategy.past.get_show","text":"Return a show from the past. Asks the the raar archive for the info. Parameters: Name Type Description Default past datetime Date to get the show name for. required Returns: Type Description str Show name from the archive for past . Source code in cridlib/strategy/past.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def get_show ( past : datetime ) -> str : \"\"\"Return a show from the past. Asks the the [raar](https://github.com/radiorabe/raar) archive for the info. Parameters: past: Date to get the show name for. Returns: Show name from the archive for `past`. \"\"\" _url = f \" { __ARCHIV_BROADCASTS_URL }{ past . year } / { past . month : 02d } / { past . day : 02d } / { past . hour : 02d }{ past . minute : 02d }{ past . second : 02d } \" # pylint: disable=line-too-long _resp = get_session () . get ( _url , timeout = 10 ) _json = _resp . json () _data = _json . get ( \"data\" ) _label = str ( _data [ 0 ] . get ( \"attributes\" ) . get ( \"label\" )) return _label . lower () . replace ( \" \" , \"-\" )","title":"get_show()"}]}